[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h1>
<a aria-hidden="true" class="anchor" href="#purpose" id="user-content-purpose"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Purpose</h1>
<p>The ObservableCollections API is an extension of the <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API">BetterCollection API</a> which adds several beneficial features, most notably observability and dynamic transformation.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#added-capabilities" id="user-content-added-capabilities"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Added Capabilities</h1>
<h2>
<a aria-hidden="true" class="anchor" href="#observability" id="user-content-observability"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Observability</h2>
<p>The most important feature of ObservableCollections is the ability to observe changes to the collection as they occur.  ObservableCollection's observability has several advantages over typical clunky collection-listening interfaces.</p>
<ul>
<li>ObservableCollection is, in fact, a collection.  Some list models (like Java Swing's) fail to even implement Java's own standard List interface.</li>
<li>Atomicity.  The fundamental observation mechanism on ObservableCollection is to be notified of each operation on a collection as soon as it occurs.  This makes it much easier to maintain derived structures and models, as the changes come one-at-a-time.</li>
<li>Transactionality.  Though most collection listener interfaces expose the notion of batching, or receiving several (usually related) updates in each event, most standard implementations of these interface have very little ability to utilize this.  Instead, the implementations contain singular add, remove, and set methods, each of which fires an event containing a single change.  ObservableCollection takes advantage of BetterCollection's <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API#transactionality">Transactionality</a> API and Qommons' Causable API to batch operations within a transaction, even if multiple Collection methods cause those operations.  This has the potential to drastically reduce the number of change events listeners receive.  And using the Qommons Causable API, those listeners may be able to reduce even further the work they must perform on multiple events with a common cause.</li>
<li>A standard.  ObservableCollection is agnostic of any particular application and its API is robust enough to use for almost any list model-like purpose.  Swing UI data model implementations which wrap ObservableCollections are supplied and wrappers around ObservableCollections should be easy to implement for any UI library model interface.  Services which would typically expose a standard List and then a custom modification listener API can be replaced with an ObservableCollection, which can drive other data models and UI models.</li>
</ul>
<h2>
<a aria-hidden="true" class="anchor" href="#dynamic-transformation" id="user-content-dynamic-transformation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Dynamic Transformation</h2>
<p>A subset of the ObservableCollection API is the Flow API.  ObservableCollection contains the <code>flow()</code> method, which returns a <code>CollectionDataFlow</code> instance.  CollectionDataFlow contains many methods that produce new CollectionDataFlow instances that are derived from the source using one of many different types of flow operations.  A derived flow instance can be collected into a new ObservableCollection.  This derived collection will maintain a dynamic connection to the root collection's data, but will present it according to the flow operations used to produce it.  The Flow API is a dynamic parallel to Java's Stream API and many Stream operations have a parallel in the Flow API.  See <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#transformations">Transformations</a> for a list of available operations.</p>
<p>The Flow API differs from the Stream API in that the Stream API produces an independent, static collection that is the result of a stream operation applied to a collection's content at the point in time that the stream was collected.  But the Flow API produces an ObservableCollection with a dynamic connection to its source, so that its content changes with the source collection's content, according to the flow's configured derivation.  So a collection derived by flow is like the result of a stream operation always applied to the collection's latest state.</p>
<p>Derived collections may be mutable, in which case they will affect the source collection (and so all other collections derived from that source) in a defined way.</p>
<p>Other dynamic transformations that produce values instead of collections are also provided:</p>
<ul>
<li>observeSize() provides an observable integer that is the collection's current size</li>
<li>observeElement() provides an ObservableElement (an ObservableValue that also functions as a BetterCollection CollectionElement) provides the first, last, or any element in the collection whose value is equivalent to the given value.</li>
<li>observeFind() provides the first, last or any element in the collection whose value passes a given test.</li>
<li>observeContains(ObservableValue) provides an observable boolean which is always equal to <code>Collection.contains(value)</code>
</li>
<li>observeContainsAll(ObservableCollection) provides an observable boolean which is always equal to <code>Collection.containsAll(collection)</code>
</li>
<li>observeContainsAny(ObservableCollection) provides an observable boolean which is always equal to <code>BetterCollection.containsAny(collection)</code>
</li>
<li>only() provides the value of the only element in the collection, or null if there is not exactly 1 element in the collection</li>
<li>reduce() provides the scalar result of a binary operation applied to all values in the collection</li>
<li>minBy()/maxBy() provide the minimum or maximum value in the collection according to a given Comparator</li>
</ul>
<h2>
<a aria-hidden="true" class="anchor" href="#run-time-type-safety" id="user-content-run-time-type-safety"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Run-time Type Safety</h2>
<p>ObservableCollection exposes the <code>getType()</code> method which returns a <a href="https://google.github.io/guava/releases/23.0/api/docs/com/google/common/reflect/TypeToken.html" rel="nofollow">TypeToken</a> describing the type of values that may be present in the collection.  Values whose type is incompatible with the collection's type cannot be added to the collection.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#formalized-element-equivalence" id="user-content-formalized-element-equivalence"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Formalized Element Equivalence</h2>
<p>As mentioned in the <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API#betterset">BetterSet</a> documentation, even Java's standard Set implementations at times bend or break the Set contract which says that a Set may never contain multiple items for which <code>item1.equals(item2)</code>.  The BetterCollection API recognizes this and instead treats element equivalence as an implementation detail of each collection.</p>
<p>The ObservableCollection API formalizes and publicizes this with the Equivalence interface and the <code>ObservableCollection.equivalence()</code> method which returns the collection's Equivalence.  Using this interface, custom notions of equivalence can be defined for any type of object and ObservableCollections can be created using these custom equivalence schemes for their value-based search and modification methods as well as ObservableSet distinctness.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#characteristics" id="user-content-characteristics"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Characteristics</h1>
<p>ObservableCollection extends <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API#betterlist">BetterList</a>.  So any ObservableCollection needs to know the position of its elements in terms of indexes.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#features" id="user-content-features"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Features</h1>
<p>The reverse method defined by BetterCollection is overridden in ObservableCollection to produce an ObservableCollection.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#extensions" id="user-content-extensions"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Extensions</h1>
<h2>
<a aria-hidden="true" class="anchor" href="#observableset" id="user-content-observableset"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>ObservableSet</h2>
<p>ObservableSet is an ObservableCollection that extends <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API#betterset">BetterSet</a>.  An ObservableSet may never contain 2 <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#formalized-element-equivalence">equivalent</a> values.  Like Java's Set and BetterSet, ObservableSet is mainly a tagging interface and adds no new features.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#observablesortedset" id="user-content-observablesortedset"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>ObservableSortedSet</h2>
<p>ObservableSortedSet is an ObservableCollection that extends <a href="https://github.com/Updownquark/Qommons/wiki/BetterCollection-API#bettersortedset">BetterSortedSet</a>.</p>
<p>ObservableSortedSet adds the <code>ObservableElement&lt;E&gt; observeRelative(Comparable&lt;E&gt;, SortedSearchFilter, Supplier&lt;E&gt;)</code> method, which supplies an observable element whose contents are the result of <code>BetterSortedSet.search(search, filter)</code> on the sorted set, or the value supplied by the supplier if the search would return a null element.</p>
<p>All the headSet/tailSet/subSet methods, as well as the subList and reverse methods, are overridden to return ObservableSortedSets.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#transformations" id="user-content-transformations"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Transformations</h1>
<p>The CollectionDataFlow interface contains many methods which produce a new flow instance (flow instances themselves are immutable) representing data derived from the source in some way.  These operations may produce a DistinctDataFlow, which is a CollectionDataFlow that produces an <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#observableset">ObservableSet</a> when collected, or a DistinctSortedDataFlow, which produces an <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#observablesortedset">ObservableSortedSet</a>.</p>
<ul>
<li>filter().  Produces a flow that may exclude some of the source flow's values.  Will be distinct or distinct-sorted as the source is.</li>
<li>map().  Produces a flow whose values are the result of a mapping function applied to the source flow's values.</li>
<li>combine().  Produces a flow whose values are the result of a mapping function applied to both the source flow's values and one or more other ObservableValues.</li>
<li>sorted(Comparator).  Produces a flow with the same values as the source flow, but ordered according to the given comparator.</li>
<li>distinct().  Produces a distinct flow according to the source's <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#formalized-element-equivalence">equivalence</a>.  Resulting collections will have the same values as the source, but with duplicate equivalent values eliminated.  Various options are available that affect the order of the resulting elements and which source element will be the representative in the distinct collection if there are other equivalent elements.</li>
<li>distinctSorted().  Produces a distinct-sorted flow according to a given comparator.</li>
<li>filterMod().  Produces a flow (distinct or distinct-sorted as the source is) that can prevent all or some modifications to the derived collection.  Changes to the source collection will still be represented in the derived collection, but the filter would be applied to any modifications coming from the derived collection.</li>
<li>immutable().  A shortcut for <code>filterMod(f-&gt;f.immutable(StdMsg.UNSUPPORTED_OPERATION, true)</code>.  Prevents any actual modification to the derived collection.  Does not prevent element updates, where the value of an element is set to the same (identical, not equivalent) value it had.</li>
<li>flatMap().  Produces a flow containing all elements from the collections produced by a CollectionDataFlow-producing mapping function applied to each of the source's values.  Analagous to Stream.flatMap(Function).</li>
<li>flattenValues().  Produces a flow containing all the values from the ObservableValues produced by an ObservableValue-producing mapping function applied to each of the source's values.</li>
<li>whereContained().  Produces a flow containing all of the source's values that are, or are not, also present in another CollectionDataFlow.</li>
<li>withEquivalence().  Produces a flow with the same data as the source, but whose <a class="internal present" href="/Updownquark/ObServe/wiki/ObservableCollection-API#formalized-element-equivalence">equivalence</a> is as specified.  Can be used before distinct() to produce ObservableSets with different equivalence than the source.</li>
<li>refresh().  Produces a flow with the same data as the source, but that fires an update on all derived elements whenever the given observable fires.  This method is useful when combined with filter or map when the filter or mapping function's results are known to be variable.  The refresh event gives the filtered collection a chance to re-evaluate the source element's inclusion in the derived collection, or allows the mapped collection to recognize that the derived value has changed even though the source hasn't.  The filter or map operation must be called on the refreshed flow (not vice-versa) for this to work.</li>
<li>refreshEach().  Produces a flow with the same data as the source, but that fires an update for its elements when the observable produced by a mapping function on the source value fires.</li>
<li>groupBy().  Produces a MultiMapFlow, which can produce an ObservableMultiMap whose key set contains all distinct values produced by the given mapping function applied to the source values, and whose values for each key are the source values for which the mapping function produced an equivalent to that key.  The version that accepts a Comparator produces a SortedMultiMapFlow. <strong>ObservableMultiMaps are not working as of this writing.</strong>
</li>
</ul>

        </div>

    </div>]