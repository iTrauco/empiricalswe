[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h2>
<a aria-hidden="true" class="anchor" href="#age-future-direction" id="user-content-age-future-direction"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>AGE Future Direction</h2>
<h3>
<a aria-hidden="true" class="anchor" href="#general-management" id="user-content-general-management"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>General Management</h3>
<ul>
<li>To be managed by a project committee</li>
<li>Initial committee to be formed of @CTrauma @Alan-FGR @boberfly @darrylryan @rokups @mattbenic @benwolf</li>
<li>All committee to have admin access all resources to ensure rapid response and no-one dying with the only set of keys.</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#general-philosophy" id="user-content-general-philosophy"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>General philosophy</h3>
<ul>
<li>Continue existing codebase, streamlining and in particular removing feature areas that cannot be maintained</li>
<li>Core is existing Urho based engine, editor, and C# scripting support on desktop platforms</li>
<li>Outside of core, any requested/desired feature or additional focus area must have a committed maintainer to be considered</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#focus-areas-and-ownership" id="user-content-focus-areas-and-ownership"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Focus areas and ownership</h3>
<table>
<thead>
<tr>
<th>Focus area</th>
<th>Responsible person(s)</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core</td>
<td>managed by a project committee</td>
<td>Most of the changes to CPP core to be backported from Urho (by Rokups?)</td>
</tr>
<tr>
<td>Android CP</td>
<td>CTrauma?</td>
<td></td>
</tr>
<tr>
<td>iOS CP</td>
<td></td>
<td>This can be left to rot and stagnate because Apple is the spawn of all evil. Or someone could volunteer to work on it.</td>
</tr>
<tr>
<td>Web CP</td>
<td></td>
<td>Would depend a build system maintainer</td>
</tr>
<tr>
<td>C# scripting support</td>
<td>mattbenicᶜ, Alan-FGR</td>
<td></td>
</tr>
<tr>
<td>JS scripting support</td>
<td></td>
<td>To be removed once editor is ported to C#, unless a maintainer is found</td>
</tr>
<tr>
<td>Editor</td>
<td>mattbenic/Alan-FGR</td>
<td>To be ported to C#, possibly by mattbenic's team &amp; Alan-FGR</td>
</tr>
<tr>
<td>UI Library</td>
<td>Rokups?</td>
<td>Might change when editor is ported, or when someone else picks up and owns it</td>
</tr>
<tr>
<td>Asset Pipeline</td>
<td></td>
<td>Some maintenance already happening in mattbenic's team, need longer term non-sucky plan - e.g. take Nem0's importer from Lumix</td>
</tr>
<tr>
<td>Modern Renderer (bgfx)</td>
<td>boberflyʷ/rokupsᶜ</td>
<td>Medium to long term goal, possibly mattbenic's team unless someone else picks it up sooner</td>
</tr>
<tr>
<td>Build System &amp; CI</td>
<td>CTrauma</td>
<td>Simplify/streamline build tech and process. Speed up builds</td>
</tr>
<tr>
<td>Unit Testing</td>
<td>CTrauma</td>
<td>Once Build System &amp; CI are completed</td>
</tr>
<tr>
<td>Examples</td>
<td>Alan-FGR</td>
<td>Alan-FGR interested in maintaining once API holes are plugged. What about JS examples?</td>
</tr>
<tr>
<td>Issues</td>
<td>mattbenicʷ/Alan-FGRʷ</td>
<td></td>
</tr>
<tr>
<td>Forums</td>
<td>maintained by committee team</td>
<td>maintained as a team</td>
</tr>
<tr>
<td>Website</td>
<td>darrylryanʷ</td>
<td></td>
</tr>
<tr>
<td>Twitter, FB</td>
<td>maintained by committee team</td>
<td>Likely minimal interaction, just occasional feature/addition announcements</td>
</tr>
<tr>
<td>Repo management</td>
<td>mattbenicᶜ/ctraumaᶜ</td>
<td>With <em>heavy</em> contributor support. Owners of particular areas to review others' PRs in those areas</td>
</tr>
</tbody>
</table>
<p>ᶜ = confirmed
ʷ = working on it
ᵃᵇᵈᵉᶠᵍʰʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛˣʸᶻ</p>
<h3>
<a aria-hidden="true" class="anchor" href="#early-discussion-summary" id="user-content-early-discussion-summary"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Early discussion summary</h3>
<p>After reading through all the chat logs over the past week I was able to slap this document together. I really didn't think about how to divide it up as much because I wanted to get it out to the community as fast as possible. Hopefully I didn't take too much out of context, it was a lot to digest in a short amount of time. Hopefully my personal bias didn't seep in anywhere, tried to be objective as much as possible which is probably why this document is as long as it it.</p>
<p>Some things stood out for me, but read the whole doc to make up your own mind of how things are weighted.</p>
<p>The things that stood out (in no particular order):</p>
<ul>
<li>We have limited resources
<ul>
<li>leverage as much third party as possible</li>
<li>possibly modularize development and runtime</li>
<li>shrink the code base to just what is required</li>
</ul>
</li>
<li>The code base is huge, which should we use?
<ul>
<li>Three way tie between fork Atomic / Use Urho / Use Lumix</li>
</ul>
</li>
<li>Bindings are incredibly important</li>
<li>BGFX is the way of the future</li>
<li>Building a 1st class editor and asset workflow is complex and time consuming</li>
<li>Having a proven codebase matters (Urho has 10+ years)</li>
<li>We need to define the audience for AGE 2.0 to drive direction</li>
<li>Xplat deployment  is required</li>
<li>Original build process is a pain point</li>
<li>CPP core with CLR/CLI ( not sure what systems are in what camp )</li>
<li>Showcasing a game could be a good way to drive use cases and features</li>
<li>2d feature should be optional</li>
<li>Atomic 1.0 was not exactly focused on the wants of the current community</li>
<li>Diverging from the current Atomic codebase will be at the cost of some current valuable resources</li>
<li>C# is an absolute must
<ul>
<li>we don't really understand the binding generator</li>
<li>API holes are a pain point</li>
<li>standardize on 3rd party binding tools</li>
<li>Asset pipeline tooling should all be managed code</li>
</ul>
</li>
<li>UI is a major pain point
<ul>
<li>IMGUI for Tools</li>
<li>UrhoUI for in game</li>
<li>TB is old, inactive  and cumbersome</li>
</ul>
</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#third-party-librariestools-mentioned" id="user-content-third-party-librariestools-mentioned"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Third party libraries/tools mentioned</h3>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/PhysX" rel="nofollow">PhysX</a> is by far the best choice for a physengine</li>
<li>I still think it should use a 3rd party lib like <a href="https://glm.g-truc.net/0.9.8/index.html" rel="nofollow">glm</a> for math</li>
<li>
<a href="https://en.wikipedia.org/wiki/PhysX" rel="nofollow">PhysX</a> is the best lib of its kind</li>
<li>
<a href="https://github.com/bkaradzic/bgfx">bgfx</a> is a better renderer</li>
<li><a href="https://github.com/nem0/LumixEngine">Lumix</a></li>
<li><a href="http://guillaumeblanc.github.io/ozz-animation/" rel="nofollow">OzzAnimation</a></li>
<li><a href="https://github.com/bulletphysics/bullet3">Bullet</a></li>
<li>
<a href="https://glm.g-truc.net/0.9.8/index.html" rel="nofollow">glm</a> vs <a href="https://bitbucket.org/blaze-lib/blaze" rel="nofollow">blaze</a> vs <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" rel="nofollow">eigen</a> vs <a href="https://github.com/creachadair/imath">imath</a>
</li>
<li>for assets I'd be quite OK going with only FBX and <a href="https://github.com/KhronosGroup/glTF">gltf</a> as long as it's top-notch... every modeller supports one of these today</li>
<li>Outsourcing work is a good thing.  <a href="http://www.swig.org/" rel="nofollow">Swig </a> could do the job</li>
<li><a href="https://github.com/nem0/OpenFBX">OpenFBX </a></li>
<li><a href="https://github.com/StatisKit/AutoWIG">AutoWIG</a></li>
<li><a href="https://github.com/KhronosGroup/glTF">GLTF </a></li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#open-source-distro-model" id="user-content-open-source-distro-model"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>open source distro model</h3>
<ul>
<li>Bunch of modules that have primary maintainers, glued together with "engine"</li>
<li>a single person can't maintain a complete engine</li>
<li>just take the most popular, stable and well-maintained open source stuff on github and glue it all together.</li>
<li>Focused libraries (modules) are much better development model than typical engine. Examples are ImGui, OzzAnimation, Bullet*, bgfx, etc. you glue all those with "engine" and you can have simple 2D game, or complex 3D game, etc. What's lacking is good high-level rendering library, something that deals with meshes, lights, materials, postproc, etc.</li>
<li>the 3d guys maintain the 3d stuff, the 2d guys maintain/contribute to the 2d stuff
as @bkaradzic earlier today said: would be really cool to have a modular engine</li>
<li>atomic would be a collection of "contracts", the rest is completely optional</li>
<li>we should atomic treat as a kernel</li>
<li>we need to define what the kernel's job should be</li>
<li>write a wrapper around bgfx, write up some contracts, everything in c# :)</li>
<li>Software distro, a set of software components (i.e. open source components) assembled into a working whole and distributed to a user community.</li>
<li>atomic is the kernel, rest are modules</li>
<li>The kernel idea is definitively a good one, but it's something that can be achieve step by step after some iterations and should be a long term target and not something to do first. I think @mattbenic is right the focus should be on what needs some love and polishing first.</li>
<li>I have a plugin system, it's totally not worth it for essential stuff</li>
<li>being able to safely disable certain components (at runtime, not bloody preprocessor) would be nice</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#atomic-fork" id="user-content-atomic-fork"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Atomic fork</h3>
<ul>
<li>urho/atomic work combined with bgfx and a new editor project</li>
<li>what's the use in making some modules for a little-known engine that nobody uses anyway? What kind of community can one expect from/for that?</li>
<li>there are too many bits of Atomic which are    undocumented/unmaintained/incomplete</li>
<li>prune off the dead branches so the plant can live</li>
<li>maybe we want an atomic core with a bgfx in front?</li>
<li>atomic has a much better community, better media, presence...</li>
<li>the c#, scripting etc is awesome</li>
<li>c# is broken, see #1644</li>
<li>atomic's strength is doing 3d well</li>
<li>working cross platform well</li>
<li>nice scripting support</li>
<li>i prefer atomic's structure</li>
<li>the build system</li>
<li>the platforms deployment</li>
<li>the main thing that kept me with atomic an not lumix is that lumix scripting sucks</li>
<li>do we want to keep atomic but with a bgfx renderer</li>
<li>I liked the promise of the editor, the turnkey build on multiple platforms, and the deployment especially on mobile, plus the script binding</li>
<li>I totally agree on having a small codebase/framework though, Atomic honestly feels too bloated</li>
<li>We're fairly invested in Atomic, we've been developing with it for the last two years, have a completed C++ product application in it, the port of that product to C# and another C# product, both of which are currently being tested for issues, and we're working on another C# project which will take some time.</li>
<li>the problem is Atomic is a huuuge project, so is Urho, but Atomic is much bigger.</li>
<li>Atomic is just too ambitious for a project with no financial backing imho</li>
<li>I guess the first thing we need to do is scale down considerably, then produce some examples and fix the API so you don't need tons of workarounds in those examples, and iterate that way, make some examples to really put the engine to actual relevant tests on real-world scenario</li>
<li>it is possible to fix things like API holes, maybe not exactly to your or a former leaders liking,</li>
<li>let's strip atomic down to it's bare minimum</li>
<li>atomic has a nice autobinder already, but need to study it</li>
<li>I don't see much to cherry pick actually, and I'd advise against picking say the math stuff while you can just go with glm which is fast and certainly much more actively maintained, you just plug it in and forget about it, that's the way to go imho</li>
<li>fix the bindings and go with managed tools, fix FBX support, add gltf (maybe) and we're gold</li>
<li>so my conclusion would be: a) drop duktape/js/ts/editor b) get a working wrapper for atomic core cpp and C#/CPP "just code" SDKs c) make a managed editor with a good asset pipeline (GLTF native support imo) d) get BGFX rendering it all</li>
<li>what is better about a C# wrapper around Atomic with a BGFX renderer in front, vs Lumix which already has a BGFX renderer and the C# wrapper in progress, and the tooling and asset pipeline is already quite mature</li>
<li>i think the main issue with atomic is that josh was trying to solve a lot of problems that none of us had
but not the ones we all have, we should start with the those</li>
<li>maybe we just keep the existing bindings and just fix the holes manual</li>
<li>Start from current Atomic rather than a new fork of Urho. Get the editor ported to C# (while addressing C# bindings in parallel if resources allow). Once the binding work is done (likely to be done before the editor) those contributors can switch to editor or even pipeline.</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#urho-based" id="user-content-urho-based"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Urho based</h3>
<ul>
<li>what about taking bits from Atomic, that are different from Urho, and keep them as modules for Urho?</li>
<li>"atomic modules for urho" is honestly way shittier than "atomic game engine".</li>
<li>Urho isn't really moving fwd these days and we'll have to keep them as 3rd party modules they won't accept them officially</li>
<li>Urho might not be not moving fwd much, but it's probably better than one of both projects dying</li>
<li>do we keep urho? when it is also in flux?</li>
<li>the problem with urho is that it is dated</li>
<li>looking at github, urho is not that more popular than atomic</li>
<li>there's no-one working on the bits urho needs</li>
<li>the only game on Steam is probably the worst game ever made</li>
<li>urho has issues, we are looking at moving to bgfx</li>
<li>I prefer the Urho architecture overall, and I've never actually uses a 'systems-first' ECS like the one in Lumix</li>
<li>Urho has more than 10 years now and it's extremely complete, but it's also a bit over-engineered</li>
<li>it's intended as a general-purpose</li>
<li>Without cadaver and weitjong honestly I have little hopes for Urho</li>
<li>Like fork urho3d, bring the fixes push bgfx, ignore 2d and make a clean simple editor</li>
<li>C# bindings with CppSharp, ignore js because it's for skiddies.. Drop Lua and angelscript and redo build system from scratch</li>
<li>the problem with the Urho architecture is that it's not going to be easy to MT it as Lumix</li>
<li>Urho is kinda obsolete and upgrading it to run well on modern hardware is certainly going to require a rather major revamp</li>
<li>The ECS implementation as we discussed also doesn't leave much room for optimization</li>
<li>on the renderer front, i think there seems consensus that Urho's future is uncertain and it is going to be harder to multithread etc</li>
<li>Urho is much more mature than Lumix, we just need a decent binding for it and strip out the extravagant stuff imho for a starter... and provide decent asset pipeline and tools</li>
<li>refork urho, strip out the extras, selectively re-add the basics in atomic</li>
<li>forking urho3d and importing stuff from atomic gives benefit of shared commit history, easier to frequently import from upstream</li>
<li>at it's core atomic is urho3d with some fixes. most of atomic is other addons like editor, bindings, tools</li>
<li>maybe we should consider changing Atomic so that Urho3d is unchanged
have it in its original structure and namespace so that its easier to maintain?</li>
<li>we should get the minimum urho wrapped and deprecate any parts which are not supported like 2d, http etc. we dont need to physically remove them, but they can be undocumented and unsupported and unused in the demos</li>
<li>while Lumix has all of that, Urho is muuuch more complete, and has 10y+ of work behind it, the core is very stable at this point  well, for a starter look at the core/engine/scene types, Urho has everything we could possibly need and honestly the code is much better</li>
<li>honestly, I really fail to see any decent opensource alternative that's dependable and performant... Urho is pretty much the only that comes to my mind, and I've seen a lot of stuff and xplat of course</li>
<li>I have not seen anything other than urho more comfy to use</li>
<li>imo the only opensource engine that's fast, proven (somewhat), and really fully featured is Urho</li>
<li>Urho is somewhat proven, at very least it was tested in a craptonne of hardware in the last 10+ years in development</li>
<li>rokups is stripping out the stuff from Urho we don't want, and is going to add IMGUI, then we bind it all (hard part) and we can maybe coordinate some efforts to start the new editor and in parallel maybe make a game or something, don't know... but the first part is pretty clearly decided isn't it?</li>
<li>so it's urho minus what we dont need plus imgui plus new wrapper plus new editor?</li>
<li>reforking urho? it would make merging from upstream often much easier and we would have benefit of knowing where certain changes came from and why. git blame would immediately become useful</li>
<li>after projects leaders leave we are talking about forks and what not, perpetuating fragmentation, while we should just work with the upstream.</li>
<li>I agree that making Atomic better compatible with upstream where possible is idea, however it's not really possible to work directly with Urho, unless the (new) maintainers there can be convinced to accept these changes</li>
<li>enough reason for Atomic to exist as a separate project. All of them together make it a no brainer
So easier updating of stuff that stays unchanged from Urho? Totally! Trying to force changes onto Urho that they don't want? Not so much.</li>
<li>Urho provides a lot of stuff outta the box... whenever I need something I always take a look to see if it's already there because chances are it is</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#bgfx" id="user-content-bgfx"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>BGFX</h3>
<ul>
<li>bgfx is a better renderer than urho's one</li>
<li>add bgfx as the lowlevel-stuff handler after that, write a thin c-interface for the autobinder</li>
<li>up to bgfx to do stuff like async compute, bindless textures, more shader stages than just compute/vert/fragment</li>
<li>shaderc is being revamped so that'll be interesting to go away from preprocessor defines, the alternative I'd preferably go like pure HLSL or GLSL and try out like SPIRV-cross to convert
the good thing is the bgfx API won't change drastically to add these in future and the engine can just update to these changes later</li>
<li>Bgfx is totally a future imho. We all here are for it</li>
<li>bgfx has been tried on a lot of hardware too which is the majority of problems for system support, second by SDL handling the rest</li>
<li>Once we have BGFX though we will also be able to easily implement the goodies that are scattered around GitHub, including GI and all kinds of crazy shaders</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#lumix-based" id="user-content-lumix-based"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Lumix based</h3>
<ul>
<li>Lumix is totally on the right track imho</li>
<li>c# for lumix?</li>
<li>let's ditch Atomic and move to Lumix</li>
<li>lumix has that stuff...</li>
<li>what if we take lumix and make it Atomic 2.0</li>
<li>would be much better to really bring the best bits of atomic into lumix</li>
<li>get c# and maybe duktape working</li>
<li>Lumix doesn't have the 2D stuff, but I don't think it should anyway</li>
<li>lumix does 3d well, but its not as good at the cross platform and the scripting</li>
<li>maybe the sensible thing would be to get the community behind lumix, and get the c# up to speed and have managed editor plugins</li>
<li>the editor is already scriptable</li>
<li>what's wrong with xplat? Afaik it's fully portable, maybe would need minor adjustments</li>
<li>we could port various bits from atomic/urho and use a lot of the smart stuff from josh in lumix i am sure</li>
<li>Also Lumix uses a real ECS which performs orders of magnitude faster and it uses PhysX</li>
<li>yep, lumix tbh is superior in most ways these days</li>
<li>lumix editor is more usable with terrain tools, trees, grass</li>
<li>@nem0 isn't going to jump the ship right @nem0?</li>
<li>if @nem0 can make c# work to a usable state, i would be inclined to think the most sensible thing might be to unite the community of urho and atomic behind lumix</li>
<li>with Lumix supporting FBX quite decently, having a usable editor, physx, bgfx, and stuff like fibers on the roadmap, and also not having all the extra stuff in Atomic.  I think it's not that hard of a choice</li>
<li>Lumix is way less ambitious but at least all problems @nem0 are solving have a clear purpose</li>
<li>I like Lumix's architecture more for a multi-threaded/cache efficient standpoint</li>
<li>the editor is in a pretty decent shape</li>
<li>the ECS system of lumix is easier to multithread as your entities are just handles and the systems are managers which you can restructure stuff so that you could make things cache/SIMD efficient</li>
<li>my mindset gravitates towards lumix and that neil engine</li>
<li>Lumix on the other hand has a very limited scope, it doesn't promise to solve absolutely all your gamedev problems, but I guess that's actually a pro</li>
<li>well I'm cool with contributing lumix or neil's engine as they both have more of the core concepts and smaller codebase, then cherry pick out of atomic</li>
<li>why don't we just use Lumix?</li>
<li>fork Lumix and call it Atomic 2?</li>
<li>what is better about a C# wrapper around Atomic with a BGFX renderer in front, vs Lumix which already has a BGFX renderer and the C# wrapper in progress, and the tooling and asset pipeline is already quite mature</li>
<li>lumix pretty much has all the bits we're saying we're going to implement</li>
<li>adding scripting support to lumix, is proably way easier then to remake atomic 2.0 i urho</li>
<li>lumix seems to solve most of the problems i have with atomic but it falls down on one massive one which is scripting support atomic has C# but if we're saying we need to fix/replace the wrapper in atomic anyway... why not just do the same with lumix</li>
<li>the ECS in Lumix is completely different so is the overall architecture @darrylryan</li>
<li>I personally prefer Lumix but I think it's 50x more work to bring it to the same level compared to Urho, for instance, completely forget about automating bindings and prepare to do everything from scratch because the ECS architecture on native side isn't OOP at all, so you'd have to wrap everything in POCOs</li>
<li>might be easier to just take lumix where we want to go</li>
<li>i think we all agree lumix isnt what we want...</li>
<li>Lumix is too big for us, no doubt about that, even @nem0 would agree I'm pretty sure</li>
<li>what puzzles me is why only lumix is being targeted as a succesor, if you want people to use what you are creating, why focus so narrowly?</li>
<li>Godot is too slow, and honestly Lumix is too bare bones atm imho</li>
<li>but imo lumix doesnt lack any of that stuff</li>
<li>lumix now has fibers and a job system for it</li>
<li>lumix lacks platforms</li>
<li>easier to add platforms than to start a whole new editor project and replace the renderer in atomic</li>
<li>only audio is missing on linux, and fibers now</li>
<li>Tbh i am still leaning towards the idea that fixing c# in lumix might be easier than fixing up atomic bindings, editor, renderer and ui</li>
<li>my ideal engine is the features of lumix with the usability of atomic i imagine it would be moving the stand out tech from atomic on top of lumix a merged engine would be amazing especially with a push on usability</li>
<li>while you guys restructure atomic, lumix seems fine to use albeit needs a little custom love for what I want out of it :)</li>
<li>lumix with proper c# support would be my best bet too</li>
<li>Well the question would be what does Lumix has that couldn't be done in Atomic at some point ?</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#editor" id="user-content-editor"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Editor</h3>
<ul>
<li>atomic editor needs work</li>
<li>if the editor could be ported to C#, I think being able to drop the need to maintain duktape support could probably trim things a bit</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#ui" id="user-content-ui"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>UI</h3>
<ul>
<li>we need a better ui like imgui with splitters and stuff</li>
<li>Maybe getting urhos UI back.. because tb is a wreck</li>
<li>a simple scenegraph/wrangling UI that ties in with git/git-lfs will do</li>
<li>ditch TB and bring UrhoUI back?</li>
<li>i guess that comes down to will @JimMarlowe get turbobadger to a state everyone is happy with it or will @rokups get the Urho UI working well with C# bindings</li>
<li>tb is dpi aware, doesnt suck fps, doesnt make eyes bleed</li>
<li>Start one with ImGui (or actually ideally look how to extract editor parts from Lumix to be usable by both runtimes)</li>
<li>urho ui can scale, although not automatically based on dpi. Easy fix. UI may need a high res texture but so would TB. Don't rendering was recently improved a lot. So people still work on and improve urho UI while TB is dead and it's code smells. I just don't see how tb would be a good idea</li>
<li>For tooling, expose ImGUI to managed and build everything with</li>
<li>tools imgui is definitely the way to go</li>
<li>then let's go with Urho, improve it where necessary (and as necessary), and ditch TB</li>
<li>I'm not saying skip WPF and use Qt, I'm saying skip both and use ImGui instead (like Lumix did)</li>
<li>imgui for tools, Urho UI for ingame</li>
<li>we are going to use imgui for tools</li>
<li>urho UI gets more development from more people. TB UI is abandonware basically. This alone is big for me</li>
<li>The best part is that since we're using IMGUI we could very easily even ship the editor with the game, so we can have a debug mode in which you can pause at any time and select stuff to inspect values</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#c-scripting--binding" id="user-content-c-scripting--binding"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>C# scripting / binding</h3>
<ul>
<li>c# is a must for me</li>
<li>real showstopper to me is [the lack of] C#</li>
<li>While its awesome that there's support for so many scripting languages, I think the big one everyone looks for these days is C#</li>
<li>me personally I'd just stick to C# because in the long static typing is better for bigger projects imho</li>
<li>C# For tools sure, for entire engine - nope.</li>
<li>Like I said tools I'm fine with (if they run on Linux), but for engine itself... That would be not for me. I agree, native core with managed tools and scripting</li>
<li>C# Scripting and tooling would be best</li>
<li>tooling that uses C#  and can be extended in C#</li>
<li>i think c# wrapper definitely should be maintained</li>
<li>I guess we should scale way down and start basically making the C# bindings work with the minimal project</li>
<li>something dead simple basically start with a usable urhosharp</li>
<li>And all attempts at C# ( for game code ) at companies where I worked failed miserably, and canceled.</li>
<li>I have nothing against C# scripting, just saying you should not lock whole engine to it, allow other scripting languages too.</li>
<li>Requiring C# is bad, being one of options is totally fine</li>
<li>The bindings will also allow you to use any clr language, not just C#, so say for example we could easily port some python importer that runs directly in the editor and calls our API, we'd just need to adapt it to ironpython</li>
<li>people telling me that C# nowadays can be built cross-platform native &amp; statically linked but I never seen any examples of it</li>
<li>C# has been top notch xplat for quite a bit of time now, there are major pain points, but that's mostly when you need specific hardware access, say for example banshee is a real nightmare, but monogame works somewhat OK on all platforms, although it fails sometimes while FNA is much more reliable but is only for desktop</li>
<li>+1 for pinvoked netcore when appropriate</li>
<li>it might be better to go the dotnetcore route and wait for it to go android vs using mono</li>
<li>autowig looked alright, some kind of template which fills in some boring manual bind code</li>
<li>what we need imho is to solve the automatic binding problem, and I honestly don't think salvaging the current generator is viable at all, no idea if autowig is an option, but I'd definitely vote for using a tool like that. In the worst case there will be some support, and also whoever is responsible for it will be learning something that's potentially useful outside the Atomic scope.</li>
<li>the top priority atm is to have something capable of decently (not perfectly) binding it to a point where we can start playing with IMGUI on the managed side to make the tools</li>
<li>one of the things that JSBind (the tool that generates JS and CS wrappers for Atomic) does is generate C wrappers for duktape. Because duktape also requires a clean c interface.</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#web-properties" id="user-content-web-properties"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Web properties</h3>
<ul>
<li>josh offered to point the domain to my wordpress site i started ( @darrylryan )</li>
<li>let's start with only this chat, the github issues and the forums, and a simple github pages website that's up to date and such</li>
<li>atomicengine.ml is a bit extravagant don't you guys think?</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#showcase-game" id="user-content-showcase-game"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Showcase Game</h3>
<ul>
<li>if we want a game to guide the development we should start with something that won't require other stuff like fbx/imgui/bgfx</li>
<li>RPG</li>
<li>Crafting</li>
<li>making a shooter which is first/third person with vehicles traditionally covers a lot of ground</li>
<li>zombies</li>
<li>3d arena shooter imho</li>
<li>Rich destruction</li>
<li>2.5D sofa shooter game could be even better start as it is smaller scope</li>
<li>i think team vs team games are good... counterstrike, tribes, battlefield etc, but combine that will ability to build bases and craft stuff, maybe resource gathering</li>
<li>perhaps you first have to mine resources, build the bases etc before the match starts?</li>
<li>we could very easily generate a ton of zombies with different clothes in fuse, make a big forest with alan imposters and some small towns</li>
<li>implement basic shooter mechanics and melee, survival food/water crap, very easy to do</li>
<li>but then we can it a step further and make it so you can gather materials and fortify your base, you can build fences, board up windows</li>
<li>you can store food</li>
<li>find a generator and hook it up and then you need to find fuel out of cars around etc. and you work together with other players to survive or fight rival groups</li>
<li>the plus points of a zombie game: all the characters are human, so not much modelling needed, not a lot of particles, spells etc</li>
<li>simple UI</li>
<li>simple AI because they are MEANT to be dumb and walk into walls</li>
<li>a zombie game, you can play alone vs the ai zombies, or with just 1 or 2 friends, or with 100 different people in several groups</li>
<li>we can easily make tons of zombies out of Fuse</li>
<li>easily make a selection of player characters, with different clothing options</li>
<li>we can build a terrain with trees and grass with alanposters</li>
<li>zombie ai can start very simple, just pathfind towards players when you see them or hear them within a radius/frustum</li>
<li>simple fps controller and gun, melee just play a swing animation and put a collider on the end of the axe, let physics calc the hits</li>
<li>but then we add some nice mechanics for survival... fixing generators, car engines, gathering food and fuel, boarding windows</li>
<li>but as well as FPS against the other team, you also have to worry about food/water and the AI zombies all over</li>
<li>i think a tribes style game could work</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#general-concerns" id="user-content-general-concerns"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>General Concerns</h3>
<ul>
<li>Atomic is relatively high-maintenance, we were wondering if we have the manpower to continue the efforts.</li>
<li>I personally don't really need a general-purpose engine like Atomic</li>
<li>I think Atomic and maybe Urho too are just too ambitious</li>
<li>they're too large to survive solely from the eventual contribution on GitHub</li>
<li>especially without their lead devs</li>
<li>some things which atomic/urho do better would be a wider scope of platforms</li>
<li>I just want to target steam/PC so no biggie for me, others might want 2D/mobile/C#
which I don't care for so much</li>
<li>I feel like Atomic solved a lot of hypothetical problems, and very few actual problems</li>
<li>too many solutions waiting for the problem, while some show stopping problems don't have solutions</li>
<li>What are peoples intended use cases/problems they would like to solve with Atomic? Without answering that fundamental question (and now seems an appropriate time to ask it) - then people are just listing nice things. Commercial product development? Hobby dev? Mobile + PC? Big games/Small games</li>
<li>to date there's not a single usable decent C# bindings for Urho, UrhoSharp has more holes than Atomic, and Atomic has some quite crazy stuff going on</li>
<li>JS still has value for me, i can code and deploy to android with it, i cant do that with c#</li>
<li>we are saying drop duktape, js and ts and the editor... and we dont understand the bindings system so we'll make a new one... and a new editor... and... pretty much every bit of it i think we feel we dont understand well enough, know how to fix, or have manpower to maintain</li>
<li>well, im still unsure of what types of games this assembly would be good for. it sounds like 3d, and after that I dunno, but there are many now open source-ish engines out there and im assuming you'd want their users to come here.</li>
<li>we were saying we need to strip down atomic and remove stuff that's too generic without a use case</li>
<li>how the heck are we gonna fix the wrapper, fix the asset pipeline, implement a new editor and replace the renderer with a MT one</li>
<li>gltf only support 4 bones per vertex afaik</li>
<li>the future of atomic comes down to one thing can we get a wrapper that is maintainable maybe a good thing would be to wrap imgui... that would tell us if we can understand josh's wrapper, or if we can make autowig or swig do the same or, urhoui</li>
<li>What does the community want in the end? What is it we want to provide? a soup to nuts game pipeline from code to deployment, with a feature game to show capabilities and test features, and for PR? Are we doing this for the game dev community as a whole? Is it customer focused or internally focused? What is the value proposition of our deliverables and who is the audience?</li>
<li>personally i think optional subsystems for physics/ui/sound/etc could totally work, but if we rip current subsystems out then it will complicate importing changes from upstream</li>
<li>"less programmer oriented" is a toy, not a tool</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#general-ideas" id="user-content-general-ideas"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>General Ideas</h3>
<ul>
<li>merge the projects...? combine the community? (urho and atomic)</li>
<li>i never saw the point in atomic doing 2d... there are a ton of good 2d engines</li>
<li>put all our effort into one engine instead of 3, and pick the one which has an active lead, a modern renderer, and working</li>
<li>come up with a value proposition, and stick with it going forward</li>
<li>I don't care about 2D too</li>
<li>make the tools do all the work as much as possible and keep the runtime minimal</li>
<li>leverage the tooling to tighten the iteration cycles</li>
<li>I want a node network that works as a dependency graph of jobs to throw at fibers :) and nest the node networks into bigger nodes that spits out .cpp code</li>
<li>I do agree there's no need for 2D focus</li>
<li>I think it's quite obvious what the community overall wants, I don't agree but it's certainly: Editor, Docs/Tuts, PBR w/ GI, and most importantly something that won't let you down midway</li>
<li>I personally just want progress. No specific features</li>
<li>it's not worth it to maintain the 2D stuff imho, at least not for a first version, we just need to produce something as usable as say unity 1.5 or something for a starter</li>
<li>shaping the API around vulkan then emulating backwards I'd go with, but backwards being ES3.1 minimum spec which is roughly GL 4.</li>
<li>cpp engine with cs tools &amp; scripting</li>
<li>I vote for C++ engine with C# tools and game logic</li>
<li>cpp engine + a maintained c interface</li>
<li>it seems we have a split, most want C# with a cpp core</li>
<li>I think what we need is CPP core with a feature complete C# wrapper</li>
<li>i think there is a a strong case put forward by some people to keep the cpp core</li>
<li>let's go fully managed for the tools, but ability to write the games in CPP still</li>
<li>2D should go - its not particularly usable or well tooled, and its a different task to maintaining 3d really</li>
<li>regarding 2d - i do not think it should be dropped. it is not focus - sure, let urho3d maintain it. or maybe someone interested in 2d will eventually come by and start contributing. i say consider removing it completely when it starts causing problems.</li>
<li>we are gonna ditch 2d and duktape by consensus already i think</li>
<li>let's also streamline the codebase so it doesn't take a ton of time to compile</li>
<li>let's ditch the dependencies we don't need</li>
<li>We need different people to take ownership of different bits</li>
<li>
<ol>
<li>Atomic will be community managed by existing contributors, all having read/write access. 2) Different bits will be managed by different people e.g. Rokups handles PRs, Alan handles forums etc. 3) If we can't agree on stuff, we lock everyone in a room until someone turns into smoke 4) atomic will drop 2d and focus on 3D only 5) we'll drop duktape, JS/TS and the current editor 6) we'll make a new C# editor 7) there will be a collaborative 3D RPG which we all work on and that will set the focus of work on the engine itself
imo we're just missing an answer to the UI question...</li>
</ol>
</li>
<li>i would even go as far as making build system painless and not providing binary builds to filter out wannabe noobs</li>
<li>use cmake/git functionality to archive those bits of the engine we dont need in the core make the build faster and the download smaller</li>
<li>so we're rather discussing just starting over, but in the model of atomic</li>
<li>i've tried every open source engine from the whole of github, sourceforge, codeplex, google code, bitbucket and every other mofo out there  and none of them are perfect but urho and lumix are the best imo</li>
<li>noobs are not supported i would even go as far as not providing binary builds to filter them out but providing easy build process without hundred steps that just works</li>
<li>if we can get autowig working i think most if not all dependencies should get wrapped</li>
<li>an engine that is more advanced then the indie crowed but now as bulky and big as unreal and unity</li>
<li>so our audience is 2D/3D/C++/C# WIN/LINUX/DROID folk as well as the casual JS netbook crowd?</li>
<li>So I guess the aim of Atomic would be along those lines:
<ul>
<li>Not trying to compete with high-end engines</li>
<li>Not trying to cater for noob as a one button press engine</li>
<li>Trying to provide a good foundation for experienced folks to build a game upon.</li>
</ul>
</li>
<li>So in that grey area somewhere in between Godot and the like and Unity/Unreal/CE..</li>
<li>I totally agree that we need to 'outsource' as much work as possible, but it's not worthy replacing some of the solid stuff we have in place</li>
<li>Here are things we need to do:
<ul>
<li>research viability of autowig/other generator (before anything else)</li>
<li>implement a gltf importer to be used as the main/preferred format for meshes (maybe the only)</li>
<li>develop managed tools and editor in IMGUI</li>
<li>also docs</li>
</ul>
</li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#general-wants" id="user-content-general-wants"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>General Wants</h3>
<ul>
<li>Platforms: Windows first, Linux or Desktop Android sometime in the future. So right now xplat isn't a huge issue for us (though knowing it's possible/available when we need it is)</li>
<li>We actively use the editor, and our artists have a laundry list of improvements they'd like for that. The biggest single issue there is really the importer, as mentioned above fbx importing is a real issue generally, not just for Atomic. We've discussed the possibility of getting Adobe's importer brought in.</li>
<li>The build system is a focus for us, because automated builds of both the editor (dev and dist versions) and players are important to our productivity. I mentioned above that I'd like to see behavior between the dev and dist build processes be closer, and I'd prioritize that.</li>
<li>Any work we do going forward would definitely be focused on C++ and C#, with the obvious exception of the editor (currently) being in JS/TS. Josh mentioned wanting to reimplement the editor in C# and it's something I'd like to see happen at some point.</li>
<li>We agree with above sentiments about the renderer, and that replacing it with bgfx could be a big improvement</li>
<li>I'd say a simple 3d modular engine that works as a template to build upon</li>
<li>Mulit platform deployment actually brought me here, with the promise of an effective development pipeline</li>
<li>my use case is a 3rd person multiplayer FPS, desktop and android</li>
<li>heck, i don't even really need 3d, since my game is 2d, but 3d is fun!</li>
<li>SDL support or decent enough multiplatform (windows/linux minimum), VR, very flexible graphics API, minimal DoD/C++11, RC++ and/or an easy autobinder, forward-thinking threading model to easily jobify things perhaps with ISPC, liberal license, solid DCC to engine pipeline, super fast/easy build system, modular with some ECS which makes it easy to do data-oriented design with (goes hand in hand with easier cache coherency and threading) flexible animation/cinematic system, IK, gpu-friendly blendshapes/deformers and/or an easy autobinder</li>
<li>launch the runtime in another process and talk to it via a socket and use runtime compiled C++ to reload gameplay code and hot-reload of assets exported</li>
<li>So - Is it this the right time to advocate for large world support?</li>
<li>you guys seems to want c++, bgfx, imgui and a modern engine</li>
<li>we're saying we want bgfx, imgui, a working extendable editor, cpp and c# support, terrain editor and tools etc. we want physx, we want sound, we want cross platform</li>
<li>I vote for Urho+BGFX+.NET+IMGUI+EDITOR+FBX&amp;GLTF, shortest path imho to have decent user-friendly fully featured 3d engine</li>
<li>I'd say modernize the rendering but have intense effects optional</li>
<li>I write 0D, 2D and 3D games in C++, JS and C#, and like to deploy on win/linux/android.</li>
<li>I want to get cook some stuff to place on my CV and also produce something that is very comfortable to use and has components that fit very well together. Think engine-work-of-art. Urho/atomic already are most of that. Doing paid support for commercial customers is also a nice thought even if it is a long shot. I am also very anti-noob because focusing on them just drags whole thing down. I am especially talking about kind of noobs that make MMOs in js and are 15 year old. I could add I expect windows/Linux/Android support myself, macos/iOS aren't exactly optional for others too. Desktop is my primary focus, Android is second.</li>
<li>better build system, better binding/wrapper generation system, editor and pipeline, bgfx, different UI system</li>
<li>mainly a really tight asset pipeline with a flexible work flow that can deploy projects to multiple platforms</li>
<li>we need something quick to compile and easy to contribute</li>
</ul>

        </div>

        <div class="wiki-footer gollum-markdown-content boxed-group" id="wiki-footer">
          <div class="boxed-group-inner wiki-auxiliary-content markdown-body">
            <p><img align="left" data-canonical-src="https://atomicwiki.us/atomicwiki_imgs/atomicLogo.png" height="22" src="https://camo.githubusercontent.com/221d0a11732835c9763ed76a29958208a863bdfd/68747470733a2f2f61746f6d696377696b692e75732f61746f6d696377696b695f696d67732f61746f6d69634c6f676f2e706e67"/><a href="https://github.com/AtomicGameEngine/AtomicGameEngine/wiki">Home</a> | Copyright (c) 2014 - 2017 THUNDERBEAST GAMES LLC</p>

          </div>
        </div>
    </div>]