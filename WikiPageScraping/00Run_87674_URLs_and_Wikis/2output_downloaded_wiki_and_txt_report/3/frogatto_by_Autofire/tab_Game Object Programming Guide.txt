[<div class="wiki-body gollum-creole-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p><tt>Editors note: This page is a touch out of date. %PROTO% has been updated.</tt> All dynamic components of a Frogatto level are controlled by objects. Objects are defined under `data/objects`. Each type of object has a FrogattoMarkupLanguage (FFL) file defining their behavior. This file may have one or more prototypes, which sets some default behaviour. For example, the ant has a prototype 'hittable', which makes the object respond to having something being thrown at it by default. Prototypes are defined in `data/object_prototypes`.</p><p>An object's definition contains several important pieces of data:</p><ul>
<li>Basic object attributes: Its ID, number of hitpoints, physical behavior such as friction and traction, whether it's solid, etc.</li>
<li>Event handlers: Attributes beginning with `on_` are event handlers. Objects receive events, and an event handler defines how the object should respond to such an event. If you see `%PROTO%` in an event, have a look at that object's prototype file for additional code. If you see `swallow_event()`, then the object's prototype's code for that event will not be run.</li>
<li>Object animations: Contained inside `[animation]` tags, these define all the animations an object can enter.</li>
</ul><h1>
<a aria-hidden="true" class="anchor" href="#object-events" id="user-content-object-events"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Object Events</h1><p>ObjectEvents are received by an object for a large variety of events. An event handler specifies what to do when an event occurs. As a simple example, to make an object bounce whenever it lands on the ground -- when the "collide_feet" event is captured -- we could mirror the y component of its velocity like this:</p><pre>on_collide_feet="set(velocity_y, -velocity_y/2)"</pre><p>An object event handler consists of a formula written in FrogattoFormulaLanguage (FFL). FFL is a _pure functional language_. That is to say, a formula does not directly modify any aspects of the game state. Rather, a formula executes, and returns results. These results are typically _commands_ that the game engine then executes on the object that triggered the event.</p><p>In the above example, the formula executes and returns a 'set' command which will set the velocity_y of the object.</p><p>The formula executed for an event handler has access to all of the ObjectProperties of the object the event is triggered on, and it may use them to calculate its result.</p><p>The formula has access to the ObjectFunctions API which contains many functions which can be used to create different kinds of commands that will be executed by the engine.</p><h1>
<a aria-hidden="true" class="anchor" href="#structures" id="user-content-structures"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Structures</h1><p>There are several logic structures that occur in FFL. 1 `if(*boolean expression*, *FFL to do if TRUE*, *FFL to do if FALSE*)` The *boolean expression* uses comparisons like `'&lt;'`, `'!='`, and so on. Expressions may be chained together using boolean logic words, like `'and'` or `'or'`. Example: `x&lt;y and y!=10`. Let's say `x = 5`. `if(x&lt;5, debug('1'), debug('2'))` would print `'2'` to screen. Now, if x was 2, that expression would print `'1'` to screen. 1 `*FFL to do with variable* where *variable* = *FFL*` Executes the first FFL statement using *variable* as the last bit which *variable* equals. For example, `debug(x) where x = 10` would print `'10'` to screen. You can have several `where`s after a statement, like `debug(x,y) where x = 10 where y = 5` would print `'105'` to screen. 1 `map(*list*, *variable*, *FFL to do*)` The *FFL to do* is executed once for each item in the *list*, with that item being called *variable* in the *FFL to do*.</p><p>Notes: FFL to do can always be a list of FFL statements. `[debug('1'), debug('2')]` just causes both expressions to be run. Also, FFL is mostly whitespace insensitive. You can put hard returns, tabs, spaces, whatever between things. For example, the pound signs in the following statement can be replaced with whitespace without any effect. `#[#debug#(#'1'#)#,#debug#(#'2'#)#]#``</p><h1>
<a aria-hidden="true" class="anchor" href="#safety" id="user-content-safety"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Safety</h1><p>In the Anura engine, math is safe. For example, a function like <tt>100/sin(x)</tt> could crash when <tt>x%180=0</tt>, but in Frogatto this perfectly OK. This eliminates a class of errors that would only crop up if certain values were assigned to <tt>x</tt>. Division by zero is equivalent to <tt>x*1000000.0</tt>. Although a bit odd to the mathematician, this relationship satisfies several basic traits that make math in Frogatto a lot nicer -- it's roughly where we expect the sequence of numbers as xâ†’0 to go. The relationship <tt>x/y &lt; 2x/y</tt> is always true. It was made this way because it adheres to the principle of least surprise. </p><p>In addition to the myriad of errors you will make when programming FFL, you may set up your own errors to make. For example, say you were to make a function that returned a percentage of the width of the current object. If your function expects a percentage between 0.0 and 1.0, you could ensure no one ever passes 50 (for 50%) to the function by mistake like this: <tt>def(percent) img_w*percent asserting percent &lt;= 1.0 and percent &gt;= 0 | 'Percent must be a decimal value between 1 and 0.'</tt> (Note: img_w is the width of the current object's image.) The <tt>asserting</tt> keyword is used to throw an error if the following condition fails. The pipe (<tt>|</tt>) specifies a message that will be outputted when the condition fails. It is good practice to include an explanation of <em>why</em> the error, as a response to "<em>why</em> won't my code run?" Always try to help the future programmer, it might just be you.</p>
        </div>

        <div class="wiki-footer gollum-markdown-content boxed-group" id="wiki-footer">
          <div class="boxed-group-inner wiki-auxiliary-content markdown-body">
            <p>More help can be found via IRC, <a href="irc://irc.freenode.net/#frogatto" rel="nofollow">#Frogatto</a> on freenode.net. This wiki is not a complete reference.</p>

          </div>
        </div>
    </div>]