[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p><a class="internal present" href="/ixdu/caravan/wiki/Gui.action-lang-specification">gui.action lang specification</a> - черновик спецификации</p>
<h3>
<a aria-hidden="true" class="anchor" href="#%D0%AD%D1%82%D0%BE-%D1%87%D0%B5%D1%80%D0%BD%D0%BE%D0%B2%D0%B8%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B0%D1%8F-%D0%BF%D0%BE%D1%80%D1%82%D1%8F%D0%BD%D0%BA%D0%B0-%D0%BF%D0%BE-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5%D0%B9-%D1%87%D0%B0%D1%81%D1%82%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D1%81%D0%BE%D0%B7%D0%BD%D0%B0%D0%BD%D0%B8%D1%8F" id="user-content-Это-черновик-рабочая-портянка-по-большей-части-поток-сознания"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Это черновик, рабочая портянка, по большей части поток сознания</h3>
<p>Главные цели концепта:</p>
<ul>
<li>анимация</li>
<li>программирование логики работы интерфейса.
Дополнительные цели:</li>
<li>реализация всей логики интерфейса</li>
<li>предобработка данных перед их отправкой сервисам, использующим ui.
На данный момент, работа над дополнительными целями не ведётся и в ближайшее время вряд ли будет вестись:)</li>
</ul>
<p>Концепт в общем то нагло содран с таких проектов как xul, gjs и QML(Qt Quck) и прежде всего QML, фактически это тоже самое, но более конвеерно подобное и без синтаксическо-семантического сахара.  Но тут вообще всё содрано, так что не обращаем внимание:)
Язык этот разработан так, чтобы:</p>
<ul>
<li>легко разбираться и перерабатываться широкораспространёнными средствами(фактически нужны только реализация json и javascript)</li>
<li>чётко отделить код, ведомый данными, работающий по разному в зависимости от ситуации от кода, который легко может быть разложен в конвеер, либо в стили(на подобии css). Вот для второго типа кода и его оптимизации и создан action_lang. Чтобы эффективно его компилировать в нечто более-менее оптимальное под конкретной платформой, где работает gui-backend(например css для стилей и преобразований в web, clutter для преобразований в gtk и тд)</li>
<li>Кроссинструментально. Конечно есть шейдеры, конечно есть css, конечно есть что-нибудь ещё, предназначенное для описания эффектов, стиле, но хоть эти технологии и кроссплатформенны, они не итероперабельны или хрен его знает как это назвать. В общем они не могут использоваться одна над другой или под другой. Нам же нужен метаязык, который будет работать поверх той или иной технологии на целевой платформе. Можно заметить, что QML достаточно независим от Qt, и в принципе кандидат на эту роль, но будем честными - нет ресурсов сейчас брать и делать собственную реализацию столь масштабного проекта как QML, а оригинальный QML завязан на Qt всё равно, не концептуально, но реализацией.</li>
<li>легко делать что-нибудь с элементами интерфейса, программировать их базовую логику, изменять их и тд.</li>
</ul>
<p>Итак, во главе концепта стоят такие понятия состояния как:</p>
<ul>
<li>
<p>state(Состояние)
Это некоторая строка, которая привязывается к некоторую элементу интерфейса, к которому возможно привязать состояние(на данный момент это пока только контейнеры, такие как panel). При это два разных элемента могут иметь одинаковое состояние на данный момент, но при этом, эти состояния будут рассматриваться независимо, то есть будут порождать независимые друг от друга цепочки действий. Если же просто, то состояние, это просто внутреннее поле-строка у элемента, на которую может реагировать некоторый объект действий.</p>
</li>
<li>
<p><code>action_object</code>(Объект действий).
Объект, объединяющий в себе сущности:</p>
</li>
<li>
<ul>
<li>catch(реагирование на состояния)</li>
</ul>
</li>
<li>
<ul>
<li>chain(цепочки действий)</li>
</ul>
</li>
<li>
<ul>
<li>code(js код)</li>
</ul>
</li>
<li>
<ul>
<li>throw(порождение состояний)</li>
</ul>
</li>
</ul>
<p><code>action_object</code> всегда работает в контексте того элемента ui, который породил состояние, которое и привело к работе объекта. Поэтому все действия, которые совершаются в рамках <code>action_object</code> модифицируют контекст именно этого элемента. И порождаемые события также привязаны к этому элементу. Исключением тут является js-код, который может порождать любые <code>action_object</code>, которые в свою очередь могут реагировать и на другие элементы ui. Но что касается js, то этот вопрос ещё прорабатывается, вполне возможно, что модификация контекста текущего элемента ui и модификация глобального контекста - будут рассматриваться независимо.</p>
<p>Итак, простейший action_object такой:</p>
<div class="highlight highlight-source-js"><pre>{
    <span class="pl-s"><span class="pl-pds">"</span>catch<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>first_state<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>throw<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>second_state<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>chain<span class="pl-pds">"</span></span> <span class="pl-k">:</span> [
        {
            <span class="pl-s"><span class="pl-pds">'</span>duration<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>10sec<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>actions<span class="pl-pds">'</span></span> <span class="pl-k">:</span> [
                {<span class="pl-s"><span class="pl-pds">"</span>move_x<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>+10<span class="pl-pds">"</span></span>},
                {<span class="pl-s"><span class="pl-pds">"</span>move_y<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>+10<span class="pl-pds">"</span></span>}
            ]
        },
        {
            <span class="pl-s"><span class="pl-pds">'</span>duration<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>20sec<span class="pl-pds">'</span></span>,
            <span class="pl-s"><span class="pl-pds">'</span>actions<span class="pl-pds">'</span></span> <span class="pl-k">:</span>[
                {<span class="pl-s"><span class="pl-pds">"</span>resize<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>+10%<span class="pl-pds">"</span></span>},
                {<span class="pl-s"><span class="pl-pds">"</span>rotate<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>+20<span class="pl-pds">"</span></span>}
            ]
        }
    ]
}</pre></div>
<p>Хотя он может быть не совсем простой, но достаточно, чтобы понять как работает и увидеть нечто полезное.
Итак, мы видим следующее. Объект отрабатывает, когда появляется <code>first_state</code>. Не будем пока отвлекаться на то, как создаётся <code>first_state</code>(но возможен например такой вариант - он создаётся кодом сигнала нажатия на кнопку). Главное, что этот объект отрабатывается <em>только тогда, когда появляется состояние <code>first_state</code></em>. Далее, это состояние убирается от элемента(да, это важный нюанс, любое состояние отменяется всякий раз, когда тот или иной объект действий поймал это состояние. Если нужно, чтобы состояние сохранялось, то оно должно быть добавлено выбрасываемые объектом действий состояния, в поле throw.</p>
<p>Далее, объект действий выбрасывает состояние <code>second_state</code>. Важно знать, что этот выброс произойдёт только тогда, когда <em>все цепочки действий и код, встроенный в объект действий будут завершены</em>. Считается, что именно отработка разных действий и меняют состояние. Отсюда и понятие состояние.</p>
<p>Далее идут цепочка действий, состоящая из действий, объединённые в объекты-группы. Каждая группа - это объект из строки <code>duration</code>(длительность в секундах или минутах) и массива действий - <code>actions</code>. В массиве содержатся действия, которые совершаются <em>одновременно</em>, потому что группы действий - это действия, которые происходят <em>одновременно</em>, в течении того времени, что указано в <code>duration</code>. В примере выше же мы видим, как элемент сначала перемещается на 10 пикселей по y и x, это делается медленно, в течении 10 секунд. Затем элемент увеличивается на 20% и поворачивается на 20 градусов по часовой стрелки, это длится 20 секунд.
Каждое действие имеет только один параметр, действие можно рассматривать как функцию, но правильнее её рассматривать как свойство(property) в понятии ООП, так как это может быть как некоторый сложный код, так и просто применение стилей, простая установка какого-то значения.</p>
<p>Разумеется, каждое действие имеет своё деление на шаги по времени, а некоторые и вообще могут совершаться только мгновенно. Поэтому при просчёте времени, компилятор <code>action_lang</code> лишь выбирает оптимальный шаг действия во времени, а не приказывает.</p>
<p>Теперь вернёмся к тому, как появляются состояния, как они отлавливаются разными элементами и как у этих элементов порождается множество <code>action_object</code>.
Допустим у нас есть два элемента-изображения. Допустим, одно находится вверху-влево, а другое вверху-вправо. Допустим, что мы хотим их плавно опустить вниз, но прим этом, чтобы когда они опустились, они заняли всё пространство внизу, то есть увеличились по шире - каждое до 50% ширины канвы. Для того, чтобы заработали какие-то <code>action_object</code>, которые сделают описанное выше, нужно сгенерировать состояние для каждого изображения. Допустим это будут состояния <code>down_start1</code> и <code>down_start2</code> для первого и второго изображения соответственно. Сделать это либо из сигнала(наш случай), либо из какого-то другого кода(а поскольку данный черновик ещё долёк до js, то это не наш случай:D).</p>
<p>Итак, у каждого изображения есть сигнал - <code>on_show</code>. Который испускается, когда элемент отображается. Нам нужно привязать к нему обработчик, делается это на псевдокоде примерно так:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">image1</span>.<span class="pl-en">signal_connect</span>(<span class="pl-s"><span class="pl-pds">'</span>on_show<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>ui.code<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>this.create_state(down_start1)<span class="pl-pds">'</span></span>);
<span class="pl-smi">image2</span>.<span class="pl-en">signal_connect</span>(<span class="pl-s"><span class="pl-pds">'</span>on_show<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>ui.code<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>this.create_state(down_start2)<span class="pl-pds">'</span></span>);
</pre></div>
<p>Как видим, ничего сложного. У объектов изображений вызываются стандартные методы <code>signal_connect</code>, но в качестве обработчика указывается не функция, а строка с кодом, которая должна исполняться на стороне клиента. В данном случае это вызов метода <code>create_state</code> у каждого изображения. this в данном случае используется как указание на текущий объект изображения, то есть код <em>уже</em> исполняется в контексте конкретного элемента, к которому присоединяется сигнал.</p>
<p>Итог: у нас есть два порождённых состояния - <code>down_start1</code> и <code>down_start2</code>. Как только они порождены, любые action_object, отлавливающие эти состояния могут <em>немедленно</em> начать свою работу.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-namespace-%D0%B8%D0%BB%D0%B8-%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D1%83%D1%82%D0%B5%D0%B9-%D0%BA-action_object%D0%B0%D0%BC-%D0%B8-%D1%82%D0%BE-%D0%BA%D0%B0%D0%BA-%D0%B2%D1%81%D1%91-%D1%8D%D1%82%D0%BE-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BE-%D1%81%D0%BE-state" id="user-content-Глобальность-локальность-namespace-или-относительность-путей-к-action_objectам-и-то-как-всё-это-связано-со-state"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Глобальность, локальность, namespace или относительность путей к <code>action_object</code>'ам и то, как всё это связано со <code>state</code>.</h2>
<p>Итак, у нас есть <code>action_object</code>, содержащий некоторую логику на <code>action_lang</code>. И у нас есть некоторое состояние.
Состояние - это поле в массиве states у элемента ui. Поэтому состояние в принципе уникально, так как идентифицируется связкой элемент ui + название состояния. Однако на это состояние может реагировать <em>любой</em> <code>action_object</code>, который отлавливает состояние с этим именем, так как реакция происходит только на <em>имя</em> состояния, без имени элемента.
Реагирующие на состояние <code>action_object</code>ы ищутся в нисходящем порядке и один объект из двух объектов с одинаковым именем, находящийся выше другого в иерархии дерева подменяет другом в реакции на состояние. Механизм аналогично перекрытию локальными переменными глобальных.</p>

        </div>

    </div>]