[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h2>
<a aria-hidden="true" class="anchor" href="#string-11" id="user-content-string-11"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>String [1/1]</h2>
<h1>
<a aria-hidden="true" class="anchor" href="#---title--difficulty" id="user-content----title--difficulty"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>| ✥ | Title | Difficulty</h1>
<p>:-:|:-:| :---- | :--------:
1 | ✅ | <a href="#valid-palindrome">Valid Palindrome</a> | Easy
2 | ✅ | <a href="#count-and-say">Count and Say</a>| Easy
3 | ✅ | <a href="#flip-game">Flip Game</a>| Easy
4 | ✅ | <a href="#implement-strstr">Implement strStr()</a>| Easy
5 | ✅ | <a href="#isomorphic-strings">Isomorphic Strings</a>| Easy
6 | ✅ | <a href="#reverse-string">Reverse String</a>| Easy
7 | ✅ | <a href="#reverse-vowels-of-a-string">Reverse Vowels of a String</a>| Easy
8 | ✅ | <a href="#length-of-last-word">Length of Last Word</a>| Easy
9 | ✅ | <a href="#palindrome-permutation">Palindrome Permutation</a>| Easy
10 | ✅ | <a href="#valid-anagram">Valid Anagram</a>| Easy
11 | ✅ | <a href="#ransom-note">Ransom Note</a>| Easy
12 | ✅ | <a href="#group-anagrams">Group Anagrams</a>| Medium
13 | ✅ | <a href="#longest-common-prefix">Longest Common Prefix</a>| Easy
14 | ✅ | <a href="#longest-substring-without-repeating-characters">Longest Substring Without Repeating Characters</a> | Medium
15 | ✅ | <a href="#one-edit-distance">One Edit Distance</a>| Medium
16 | ✅ | <a href="#word-pattern">Word Pattern</a>| Easy
17 | ✅ | <a href="#minimum-window-substring">Minimum Window Substring</a> | Hard
18 | ✅ | <a href="#text-justification">Text Justification</a>| Hard
19 | ⛔️ | <a href="#reverse-words-in-a-string">Reverse Words in a String</a> | Medium
20 | ✅ | <a href="#reverse-words-in-a-string-ii">Reverse Words in a String II</a> | Medium
21 | ✅ | <a href="#add-strings">Add Strings</a> | Easy
22 | ⛔️ | <a href="#multiply-strings">Multiply Strings</a> | Medium</p>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#valid-palindrome" id="user-content-valid-palindrome"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/valid-palindrome/" rel="nofollow">Valid Palindrome</a>
</h4>
<blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.
</code></pre>
<blockquote>
<p><strong>Note</strong>:
Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
</blockquote>
<blockquote>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<details><summary>Process to lowercased, scan from left and right, skip if not alphanumeric</summary><p>
```swift
// Swift
class Solution {
    func isPalindrome(_ s: String) -&gt; Bool {
        var chars = Array(s.lowercased().characters)
</p>
<pre><code>    var left = 0
    var right = chars.count - 1
    while left &lt; right {
        while !chars[left].isAlphanumeric &amp;&amp; left &lt; right {
            left += 1
        }
        
        while !chars[right].isAlphanumeric &amp;&amp; left &lt; right {
            right -= 1
        }
        
        if chars[left] == chars[right] {
            left += 1
            right -= 1
        } else {
            return false
        }
    }
    
    return true
}
</code></pre>
<p>}</p>
<p>extension Character {
var value: UInt32? {
return String(self).unicodeScalars.first?.value
}</p>
<pre><code>// var isAlphanumeric: Bool {
//     guard let value = self.value else { return false }
//     return 
//     ("a".unicodeScalars.first!.value &lt;= value &amp;&amp; value &lt;= "z".unicodeScalars.first!.value)
//     ||
//     ("A".unicodeScalars.first!.value &lt;= value &amp;&amp; value &lt;= "Z".unicodeScalars.first!.value)
//     ||
//     ("0".unicodeScalars.first!.value &lt;= value &amp;&amp; value &lt;= "9".unicodeScalars.first!.value)
// }

var isAlphanumeric: Bool {
    guard let char = String(self).unicodeScalars.first else {
        fatalError("Character is invalid")
    }

    return CharacterSet.alphanumerics.contains(char)
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Count and Say](https://leetcode.com/problems/count-and-say/)
&gt; The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

&gt;
</code></pre>
<p>1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth sequence.</p>
<pre><code>
&gt; **Note**: The sequence of integers will be represented as a string.

&lt;details&gt;&lt;summary&gt;Iterate and count&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func countAndSay(_ n: Int) -&gt; String {
		var res = ""
		guard n &gt; 0 else { return res }
		
		res = "1"
		for _ in 1..&lt;n {
			let resChars = [Character](res.characters)
			var nextString = ""
			var lastChar = resChars[0]
			var count = 1
			var j = 1
			while j &lt; resChars.count {
				if resChars[j] == lastChar {
					count += 1
				} else {
					nextString += "\(count)\(lastChar)"
					count = 1
				}
				
				lastChar = resChars[j]
				j += 1
			}
			nextString += "\(count)\(lastChar)"
			res = nextString
		}
		
		return res
	}
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#flip-game" id="user-content-flip-game"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/flip-game/" rel="nofollow">Flip Game</a>
</h4>
<blockquote>
<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
</blockquote>
<blockquote>
<p>Write a function to compute all possible states of the string after one valid move.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given s = "++++", after one move, it may become one of the following states:
[
  "--++",
  "+--+",
  "++--"
]
</code></pre>
<blockquote>
<p>If there is no valid move, return an empty list [].</p>
</blockquote>
<details><summary>Go through from left to right, if meet two consequent "--", flip</summary><p>
```swift
// Swift
class Solution {
    func generatePossibleNextMoves(_ s: String) -&gt; [String] {
        let chars = [Character](s.characters)
        var res = [String]()
        if chars.count &lt;= 1 { return res }
</p>
<pre><code>    for i in 0..&lt;chars.count - 1 {
        if chars[i] != chars[i + 1] {
            continue
        }
        if chars[i] == "+" {
            var newStr = String(chars[0..&lt;i]) + "--"
            if i + 2 &lt; chars.count {
                newStr += String(chars[i + 2..&lt;chars.count])
            }
            res.append(newStr)
        }
    }
    return res
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Implement strStr()](https://leetcode.com/problems/implement-strstr/)
&gt; Implement strStr().

&gt; Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

&lt;details&gt;&lt;summary&gt;Compare first char, if equals, compare rest&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func strStr(_ haystack: String, _ needle: String) -&gt; Int {
        let haystack = [Character](haystack.characters)
        let needle = [Character](needle.characters)
        
        guard needle.count &lt;= haystack.count else { return -1 }
        
        if haystack.count == 0 { return 0 }
        if needle.count == 0 { return 0 }
        
        for i in 0..&lt;haystack.count {
            // There's no enough characters to compare
            if haystack.count - i &lt; needle.count {
                return -1
            }
            
            // Compare first
            var j = 0
            if needle[j] == haystack[i] {
                var ii = i
                while j &lt; needle.count, ii &lt; haystack.count {
                    if needle[j] == haystack[ii] {
                        j += 1
                        ii += 1
                    } else {
                        break
                    }
                }
                
                if j == needle.count {
                    return i
                }
            }
        }
        
        return -1
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#isomorphic-strings" id="user-content-isomorphic-strings"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/isomorphic-strings/" rel="nofollow">Isomorphic Strings</a>
</h4>
<blockquote>
<p>Given two strings s and t, determine if they are isomorphic.</p>
</blockquote>
<blockquote>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
</blockquote>
<blockquote>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given "egg", "add", return true.
Given "foo", "bar", return false.
Given "paper", "title", return true.
</code></pre>
<blockquote>
<p><strong>Note</strong>: You may assume both s and t have the same length.</p>
</blockquote>
<details><summary>Use two hashes, check if key/value matches</summary><p>
```swift
// Swift
class Solution {
    func isIsomorphic(_ s: String, _ t: String) -&gt; Bool {
        let s = [Character](s.characters)
		let t = [Character](t.characters)
		guard s.count == t.count else { return false }
</p>
<pre><code>	// egg -&gt; add
	// e -&gt; a
	// g -&gt; d
	var map: [Character : Character] = [:]
	var reversedMap: [Character : Character] = [:]
	for i in 0..&lt;s.count {
		if let value = map[s[i]] {
			if value != t[i] { return false }
		} else {
		    // if cannot find skey in map, but find tKey in reversed map
		    // check the reversed key
			if let key = reversedMap[t[i]] {
				if key != s[i] { return false }
			}
			map[s[i]] = t[i]
			reversedMap[t[i]] = s[i]
		}
	}
	return true
}
</code></pre>
<p>}</p>
<pre><code>
A better way
```swift
// Swift
class Solution {
    func isIsomorphic(_ s: String, _ t: String) -&gt; Bool {
        let s = [Character](s.characters)
		let t = [Character](t.characters)
		if s.count != t.count {
		    return false
		}
		
		var sDict = [Character : Character]()
		var tDict = [Character : Character]()
		
		for i in 0..&lt;s.count {
		    if sDict[s[i]] == nil &amp;&amp; tDict[t[i]] == nil {
		        sDict[s[i]] = t[i]
		        tDict[t[i]] = s[i]
		    }
		    else if sDict[s[i]] != t[i] || tDict[t[i]] != s[i] {
		        return false
		    }
		}
		
		return true
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#reverse-string" id="user-content-reverse-string"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/reverse-string/" rel="nofollow">Reverse String</a>
</h4>
<blockquote>
<p>Write a function that takes a string as input and returns the string reversed.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Example:
Given s = "hello", return "olleh".
</code></pre>
<details><summary>Straightforward solution</summary><p>
```swift
// Swift
class Solution {
    func reverseString(_ s: String) -&gt; String {
         var s = Array(s.characters)
         if s.count == 0 {
             return ""
         }
</p>
<pre><code>     var i = 0
     var j = s.count - 1
     while i &lt; j {
         (s[i], s[j]) = (s[j], s[i])
         i += 1
         j -= 1
     }
     return String(s)
}
</code></pre>
<p>}</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> Swift</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">reverseString</span>(<span class="pl-en">_</span> <span class="pl-smi">s</span>: <span class="pl-c1">String</span>) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
        <span class="pl-k">var</span> s <span class="pl-k">=</span> [<span class="pl-c1">Character</span>](s.<span class="pl-c1">characters</span>)
		<span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span>s.<span class="pl-c1">count</span> <span class="pl-k">/</span> <span class="pl-c1">2</span> {
			(s[i], s[s.<span class="pl-c1">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> i]) <span class="pl-k">=</span> (s[s.<span class="pl-c1">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> i], s[i])
		}
		<span class="pl-k">return</span> <span class="pl-c1">String</span>(s)
    }
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#reverse-vowels-of-a-string" id="user-content-reverse-vowels-of-a-string"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" rel="nofollow">Reverse Vowels of a String</a>
</h4>
<blockquote>
<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Example 1:
Given s = "hello", return "holle".
</code></pre>
<blockquote>
</blockquote>
<pre><code>Example 2:
Given s = "leetcode", return "leotcede".
</code></pre>
<blockquote>
<p><strong>Note</strong>:
The vowels does not include the letter "y".</p>
</blockquote>
<details><summary>Get indices of vowels and reverse it</summary><p>
```swift
// Swift
class Solution {
    func reverseVowels(_ s: String) -&gt; String {
        var s = [Character](s.characters)
        var vowelsIndices: [Int] = []
</p>
<pre><code>    for (index, char) in s.enumerated() {
        if char == "a" || char == "e" || char == "i" || char == "o" || char == "u" ||
        char == "A" || char == "E" || char == "I" || char == "O" || char == "U" 
        {
            vowelsIndices.append(index)
        }
    }
    
    for i in 0..&lt;vowelsIndices.count / 2 {
        let left = vowelsIndices[i]
        let right = vowelsIndices[vowelsIndices.count - 1 - i]
        (s[left], s[right]) = (s[right], s[left])
    }
    
    return String(s)
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;Use two pointers, left and right, skip if needed. Just like [ValidPalindrome](#valid-palindrome)&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#length-of-last-word" id="user-content-length-of-last-word"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/length-of-last-word/" rel="nofollow">Length of Last Word</a>
</h4>
<blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.</p>
</blockquote>
<blockquote>
<p>If the last word does not exist, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: A word is defined as a character sequence consists of non-space characters only.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, 
Given s = "Hello World",
return 5.
</code></pre>
<details><summary>Split by " ", get last count</summary><p>
```swift
// Swift
class Solution {
    func lengthOfLastWord(_ s: String) -&gt; Int {
        return s.characters.split(separator: " ").last?.count ?? 0
    }
}
```
</p></details>
<details><summary>Scan from end</summary><p>
```swift
// Swift
class LengthLastWord {
    func lengthOfLastWord(s: String) -&gt; Int {
        var res = 0
        var sChars = [Character](s.characters)
</p>
<pre><code>    guard sChars.count != 0 else {
        return 0
    }
    
    for i in (0 ... sChars.count - 1).reverse() {
        if res == 0 {
            if sChars[i] == " " {
                continue
            } else {
                res += 1
            }
        } else {
            if sChars[i] == " " {
                break
            } else {
                res += 1
            }
        }
    }
    
    return res
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/)
&gt; Given a string, determine if a permutation of the string could form a palindrome.

&gt;
</code></pre>
<p>For example,
"code" -&gt; False, "aab" -&gt; True, "carerac" -&gt; True.</p>
<pre><code>
&gt; Hint:
- Consider the palindromes of odd vs even length. What difference do you notice?
- Count the frequency of each character.
- If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?

&lt;details&gt;&lt;summary&gt;Calculate word frequency&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func canPermutePalindrome(_ s: String) -&gt; Bool {
		let s = [Character](s.characters)
		var freq: [Character : Int] = [:]
		var oddCount: Int = 0
		
		for i in 0..&lt;s.count {
		    freq[s[i]] = (freq[s[i]] ?? 0) + 1
		}
		
		for (_, value) in freq {
			if value % 2 == 1 {
				oddCount += 1
			}
			
			if oddCount &gt;= 2 {
				return false
			}
		}
		
		return true
	}
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#valid-anagram" id="user-content-valid-anagram"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/valid-anagram/" rel="nofollow">Valid Anagram</a>
</h4>
<blockquote>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.
</code></pre>
<blockquote>
<p><strong>Note</strong>:
You may assume the string contains only lowercase alphabets.</p>
</blockquote>
<blockquote>
<p><strong>Follow up</strong>:
What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
</blockquote>
<details><summary>Sorted and compare</summary><p>
```swift
// Swift
class Solution {
    func isAnagram(_ s: String, _ t: String) -&gt; Bool {
        let s = [Character](s.characters)
        let t = [Character](t.characters)
        return s.sorted() == t.sorted()
    }
}
```
</p></details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#ransom-note" id="user-content-ransom-note"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/ransom-note/" rel="nofollow">Ransom Note</a>
</h4>
<blockquote>
<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
</blockquote>
<blockquote>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:
You may assume that both strings contain only lowercase letters.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>canConstruct("a", "b") -&gt; false
canConstruct("aa", "ab") -&gt; false
canConstruct("("aa")", "aab") -&gt; true
</code></pre>
<details><summary>Calculate word frequency</summary><p>
```swift
// Swift
class Solution {
    func canConstruct(_ ransomNote: String, _ magazine: String) -&gt; Bool {
        let ransomNote = [Character](ransomNote.characters)
        let magazine = [Character](magazine.characters)
</p>
<pre><code>    var freq: [Character : Int] = [:]
    for i in 0..&lt;magazine.count {
        if let count = freq[magazine[i]] {
            freq[magazine[i]] = count + 1
        } else {
            freq[magazine[i]] = 1
        }
    }
    
    for i in 0..&lt;ransomNote.count {
        if let count = freq[ransomNote[i]] {
            if count == 0 {
                return false 
            }
            freq[ransomNote[i]] = count - 1
        } else {
            return false 
        }
    }
    
    return true
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Group Anagrams](https://leetcode.com/problems/anagrams/)
&gt; Given an array of strings, group anagrams together.

&gt;
</code></pre>
<p>For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],
Return:
[
["ate", "eat","tea"],
["nat","tan"],
["bat"]
]</p>
<pre><code>
&gt; **Note**: All inputs will be in lower-case.

&lt;details&gt;&lt;summary&gt;Use sorted string as key, return values&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func groupAnagrams(_ strs: [String]) -&gt; [[String]] {
        var grouped: [String : [String]] = [:]
        strs.forEach {
            let key = String($0.characters.sorted())
            if let value = grouped[key] {
                grouped[key] = value + [$0]
            } else {
                grouped[key] = [$0]
            }
        }
        
        return Array(grouped.values)
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#longest-common-prefix" id="user-content-longest-common-prefix"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/longest-common-prefix/" rel="nofollow">Longest Common Prefix</a>
</h4>
<blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>
<details><summary>Use first string, check each char in rest strings</summary><p>
</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> Swift</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">longestCommonPrefix1</span>(<span class="pl-en">_</span> <span class="pl-smi">strs</span>: [<span class="pl-c1">String</span>]) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
        <span class="pl-k">var</span> res <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
		<span class="pl-k">guard</span> strs.<span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">else</span> { <span class="pl-k">return</span> res }
		<span class="pl-k">if</span> strs.<span class="pl-c1">count</span> <span class="pl-k">==</span> <span class="pl-c1">1</span> {
			<span class="pl-k">return</span> strs[<span class="pl-c1">0</span>]
		}
		
		<span class="pl-k">let</span> first <span class="pl-k">=</span> strs[<span class="pl-c1">0</span>].<span class="pl-c1">characters</span>
		<span class="pl-k">for</span> (i, char) <span class="pl-k">in</span> first.<span class="pl-c1">enumerated</span>() {
			<span class="pl-k">for</span> j <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">..&lt;</span>strs.<span class="pl-c1">count</span> {
				<span class="pl-k">let</span> chars <span class="pl-k">=</span> strs[j].<span class="pl-c1">characters</span>
				<span class="pl-k">if</span> i <span class="pl-k">&gt;=</span> chars.<span class="pl-c1">count</span> {
					<span class="pl-k">return</span> res
				}
				<span class="pl-k">else</span> <span class="pl-k">if</span> char <span class="pl-k">!=</span> chars[chars.<span class="pl-c1">index</span>(chars.<span class="pl-c1">startIndex</span>, <span class="pl-c1">offsetBy</span>: i)] {
					<span class="pl-k">return</span> res
				}
			}
			
			res.<span class="pl-c1">append</span>(char)
		}
		
		<span class="pl-k">return</span> res
    }
    
    <span class="pl-k">func</span> <span class="pl-en">longestCommonPrefix</span>(<span class="pl-en">_</span> <span class="pl-smi">strs</span>: [<span class="pl-c1">String</span>]) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
        <span class="pl-k">guard</span> strs.<span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
        }
    
        <span class="pl-k">var</span> res <span class="pl-k">=</span> [<span class="pl-c1">Character</span>](strs[<span class="pl-c1">0</span>].<span class="pl-c1">characters</span>)
        
        <span class="pl-k">for</span> str <span class="pl-k">in</span> strs {
            <span class="pl-k">var</span> strContent <span class="pl-k">=</span> [<span class="pl-c1">Character</span>](str.<span class="pl-c1">characters</span>)
            
            <span class="pl-k">if</span> res.<span class="pl-c1">count</span> <span class="pl-k">&gt;</span> strContent.<span class="pl-c1">count</span> {
                res <span class="pl-k">=</span> <span class="pl-c1">Array</span>(res[<span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> strContent.<span class="pl-c1">count</span>])
            }
            
            <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> res.<span class="pl-c1">count</span> {
                <span class="pl-k">if</span> res[i] <span class="pl-k">!=</span> strContent[i] {
                    res <span class="pl-k">=</span> <span class="pl-c1">Array</span>(res[<span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> i])
                    <span class="pl-k">break</span>
                }
            }
        }
        
        <span class="pl-k">return</span> <span class="pl-c1">String</span>(res)
    }
    
    <span class="pl-k">func</span> <span class="pl-en">longestCommonPrefix2</span>(<span class="pl-en">_</span> <span class="pl-smi">strs</span>: [<span class="pl-c1">String</span>]) <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> {
		<span class="pl-k">if</span> strs.<span class="pl-c1">count</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> {
			<span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
		}
		
		<span class="pl-k">if</span> strs.<span class="pl-c1">count</span> <span class="pl-k">==</span> <span class="pl-c1">1</span> {
			<span class="pl-k">return</span> strs[<span class="pl-c1">0</span>]
		}
		
		<span class="pl-k">let</span> stringsMaxLength <span class="pl-k">=</span> strs.<span class="pl-c1">map</span> { <span class="pl-c1">Int</span>(<span class="pl-c1">$0</span>.<span class="pl-c1">characters</span>.<span class="pl-c1">count</span>) }.<span class="pl-c1">max</span>()<span class="pl-k">!</span>
		
		<span class="pl-k">let</span> stringsMaxIndex <span class="pl-k">=</span> strs.<span class="pl-c1">count</span>
		
		<span class="pl-k">var</span> commonPrefix <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
		
		<span class="pl-k">for</span> checkingIndex <span class="pl-k">in</span> <span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> stringsMaxLength {
			<span class="pl-k">var</span> lastChar <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
			<span class="pl-k">for</span> stringIndex <span class="pl-k">in</span> <span class="pl-c1">0</span> <span class="pl-k">..&lt;</span> stringsMaxIndex {
				<span class="pl-k">let</span> string <span class="pl-k">=</span> strs[stringIndex]
				
				<span class="pl-k">if</span> checkingIndex <span class="pl-k">&gt;=</span> string.<span class="pl-c1">characters</span>.<span class="pl-c1">count</span> {
					<span class="pl-k">return</span> commonPrefix
				}
				
				<span class="pl-k">let</span> char <span class="pl-k">=</span> <span class="pl-c1">String</span>(string[string.<span class="pl-c1">index</span>(string.<span class="pl-c1">startIndex</span>, <span class="pl-c1">offsetBy</span>: checkingIndex)])
				
				<span class="pl-k">if</span> lastChar <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> {
					lastChar <span class="pl-k">=</span> char
					<span class="pl-k">continue</span>
				} <span class="pl-k">else</span> <span class="pl-k">if</span> lastChar <span class="pl-k">==</span> char {
					<span class="pl-k">if</span> stringIndex <span class="pl-k">==</span> stringsMaxIndex <span class="pl-k">-</span> <span class="pl-c1">1</span> {
						commonPrefix <span class="pl-k">+=</span> char
					} <span class="pl-k">else</span> {
						<span class="pl-k">continue</span>
					}
				} <span class="pl-k">else</span> {
					<span class="pl-k">return</span> commonPrefix
				}
			}
		}
		
		<span class="pl-k">return</span> commonPrefix
	}
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#longest-substring-without-repeating-characters" id="user-content-longest-substring-without-repeating-characters"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" rel="nofollow">Longest Substring Without Repeating Characters</a>
</h4>
<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Examples:
Given "abcabcbb", the answer is "abc", which the length is 3.
Given "bbbbb", the answer is "b", with the length of 1.
Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
</code></pre>
<details><summary>DP solution</summary><p>
```swift
// Swift
class Solution {
    // DP simplified
    func lengthOfLongestSubstring(_ s: String) -&gt; Int {
        let chars = Array(s.characters)
        if chars.count == 0 {
            return 0
        }
</p>
<pre><code>    var dict = [Character : Int]() // character to index
    
    var res: Int = 1
    var len: Int = 1
    dict[chars[0]] = 0
    for i in 1..&lt;chars.count {
        if let previousIndex = dict[chars[i]] {
            len = min(len + 1, i - previousIndex)
        }
        else {
            len += 1
        }
        dict[chars[i]] = i
        res = max(res, len)
    }
    
    return res
}

// DP
func lengthOfLongestSubstringDP(_ s: String) -&gt; Int {
    let chars = Array(s.characters)
    if chars.count == 0 {
        return 0
    }
    
    var s = [Int : Int]() // s[i] stands for longest substring ends at index i
    var dict = [Character : Int]() // character to index
    
    s[0] = 1
    dict[chars[0]] = 0
    for i in 1..&lt;chars.count {
        if let previousIndex = dict[chars[i]] {
            s[i] = min(s[i - 1]! + 1, i - previousIndex)
        }
        else {
            s[i] = s[i - 1]! + 1
        }
        dict[chars[i]] = i
    }
    
    return s.values.max()!
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;Other historical solutions&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func lengthOfLongestSubstring3(_ s: String) -&gt; Int {
        guard s.isEmpty == false else { return 0 }
		let s = [Character](s.characters)
		var i = 0
		var j = 0
		var dict = [Character : Int]()
		var res = 0
		
		while i &lt; s.count &amp;&amp; j &lt; s.count {
		    // If there's existing index and existing index is greater than i
			if let prevJIndex = dict[s[j]], prevJIndex &gt;= i {
				i = max(i, prevJIndex) + 1
			}
			dict[s[j]] = j
			res = max(res, j - i + 1)
			j += 1
		}
		return res
    }
    
    func lengthOfLongestSubstring2(_ s: String) -&gt; Int {
        guard s.isEmpty == false else { return 0 }
        var i = 0
        var j = 0
        let s = [Character](s.characters)
        var res = 0
        
        var set = Set&lt;Character&gt;()
        while i &lt;  s.count &amp;&amp; j &lt; s.count {
            if set.contains(s[j]) {
                set.remove(s[i])
                i += 1
            } else {
                set.insert(s[j])
                res = max(res, j - i + 1)
                j += 1
            }
        }
        return res
    }
    
    func lengthOfLongestSubstring1(_ s: String) -&gt; Int {
        guard s.isEmpty == false else { return 0 }
        let s = [Character](s.characters)
        var i = 0
        var j = i + 1
        var max = 1
        var pos: [Character : Int] = [s[0] : 0]
       
        while j &lt; s.count {
            // if find duplicated
            if let existedIndex = pos[s[j]] {
                if s[i] == s[j] {
                    i += 1
                } else {
                    for (k, v) in pos {
                        if v &lt;= existedIndex {
                            pos.removeValue(forKey: k)
                        }
                    }
                    i = existedIndex + 1
                }
            }
            
            if j - i + 1 &gt; max {
                max = j - i + 1
            }
            pos[s[j]] = j
            j += 1
        }
        
        return max
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#one-edit-distance" id="user-content-one-edit-distance"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/one-edit-distance/" rel="nofollow">One Edit Distance</a>
</h4>
<blockquote>
<p>Given two strings S and T, determine if they are both one edit distance apart.</p>
</blockquote>
<details><summary>Check for three cases</summary><p>
```swift
// Swift
class Solution {
    func isOneEditDistance(_ s: String, _ t: String) -&gt; Bool {
        let s = Array(s.characters)
        let t = Array(t.characters)
</p>
<pre><code>    if abs(s.count - t.count) &gt; 1 {
        return false
    }
    
    // delete
    // s: a b c  |  a b c
    // t: a   c  |  a b
    if s.count &gt; t.count {
        var p1 = 0
        var p2 = 0
        while p1 &lt; s.count &amp;&amp; p2 &lt; t.count {
            if s[p1] != t[p2] {
                if p1 == p2 + 1 {
                    return false
                }
                else {
                    p1 += 1
                    continue
                }
            }
            p1 += 1
            p2 += 1
        }
        return true
    }
    
    // add
    // s: a   b c  |  a b c
    // t: a x b c  |  a b c x
    else if s.count &lt; t.count {
        var p1 = 0
        var p2 = 0
        while p1 &lt; s.count &amp;&amp; p2 &lt; t.count {
            if s[p1] != t[p2] {
                if p2 == p1 + 1 {
                    return false
                }
                else {
                    p2 += 1
                    continue
                }
            }
            p1 += 1
            p2 += 1
        }
        return true
    }
    
    // replace
    // s: a x c
    // t: a y c
    else {
        var foundDiff = false
        for i in 0..&lt;s.count {
            if s[i] != t[i] {
                if foundDiff == true {
                    return false
                }
                else {
                    foundDiff = true
                }
            }
        }
        return foundDiff
    }
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;Check in one iteration&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func isOneEditDistance(_ s: String, _ t: String) -&gt; Bool {
        let s = Array(s.characters)
        let t = Array(t.characters)
        
        if abs(s.count - t.count) &gt; 1 {
            return false
        }
        
        // delete
        // s: a b c  |  a b c
        // t: a   c  |  a b
        
        // add
        // s: a   b c  |  a b c
        // t: a x b c  |  a b c x
        
        // replace
        // s: a x c
        // t: a y c
        for i in 0..&lt;min(s.count, t.count) {
            if s[i] != t[i] {
                // if not equal, compare rest string
                if s.count &gt; t.count {
                    return s[i + 1..&lt;s.count] == t[i..&lt;t.count]
                }
                else if s.count &lt; t.count {
                    return s[i..&lt;s.count] == t[i + 1..&lt;t.count]
                }
                else {
                    return s[i + 1..&lt;s.count] == t[i + 1..&lt;t.count]
                }
            }
        }
        
        // One string has zero length, difference must be 1
        return abs(s.count - t.count) == 1
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#word-pattern" id="user-content-word-pattern"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/word-pattern/" rel="nofollow">Word Pattern</a>
</h4>
<blockquote>
<p>Given a pattern and a string str, find if str follows the same pattern.</p>
</blockquote>
<blockquote>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Examples:
pattern = "abba", str = "dog cat cat dog" should return true.
pattern = "abba", str = "dog cat cat fish" should return false.
pattern = "aaaa", str = "dog cat cat dog" should return false.
pattern = "abba", str = "dog dog dog dog" should return false.
</code></pre>
<blockquote>
<p><strong>Notes</strong>:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</p>
</blockquote>
<details><summary>Proces two strings to numbered pattern, compare numbered pattern</summary><p>
```swift
// Swift
class Solution {
    func wordPattern(_ pattern: String, _ str: String) -&gt; Bool {
        // Process pattern
        let pattern = pattern.characters.map { String($0) }
        // Process str
		let strs = str.characters.split(separator: " ").map { String($0) }
</p>
<pre><code>    return getPattern(pattern) == getPattern(strs)
}

private func getPattern(_ strs: [String]) -&gt; String {
    var dict: [String : Int] = [:]
    var lastValue = 0
    
    strs.forEach {
        if dict[$0] == nil {
            lastValue += 1
            dict[$0] = lastValue
        }
    }
    
    return strs.reduce("") { $0 + String(dict[$1]!) }
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
&gt; Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

&gt;
</code></pre>
<p>For example,
S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC".</p>
<pre><code>
&gt; **Note**:
- If there is no such window in S that covers all characters in T, return the empty string "".
- If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.

&lt;details&gt;&lt;summary&gt;Use two pointers to slide window (increase end to find a valid window, decrease start to find the min window), use words frequency dict to help checking whether t is still in the window&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    
    // 1. Use two pointers: start and end to represent a window.
    // 2. Move end to find a valid window.
    // 3. When a valid window is found, move start to find a smaller window.
    func minWindow(_ s: String, _ t: String) -&gt; String {
        let s = Array(s.characters)
        let t = Array(t.characters)
        
        // edge case
        if s.count &lt; t.count { return "" }
        
        var start = 0 // window start index
        var end = 0 // window end index (non-inclusive)
        var charsToMatch = t.count // count of chars to match
        var freq = [Character : Int]() // frequency of chars in t
        for char in t {
            if let count = freq[char] {
                freq[char] = count + 1
            }
            else {
                freq[char] = 1
            }
        }
        
        // results
        var windowStart = -1
        var windowLength = Int.max
        
        while end &lt; s.count {
            // move end, to increase window
            if let count = freq[s[end]] {
                // if count to match for this char is postive, decrease charsToMatch
                if count &gt; 0 {
                    charsToMatch -= 1
                }
                
                // char count could be negative, which means duplicated char matched
                freq[s[end]] = count - 1
            }
            
            end += 1
            
            // if now is a valid window (charsToMatch now is 0), move start to decrease start
            while charsToMatch == 0 {
                // Update window if needed
                if windowLength &gt; (end - start) {
                    windowStart = start
                    windowLength = end - start
                }
                
                if let count = freq[s[start]] {
                    freq[s[start]] = count + 1
                    
                    // if char freq is positive, needs to increase charsToMatch
                    if count + 1 &gt; 0 {
                        charsToMatch += 1
                    }
                }
                
                start += 1
            }
        }
        
        if windowStart != -1 {
            return String(s[windowStart..&lt;windowStart + windowLength])
        } else {
            return ""
        }
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#text-justification" id="user-content-text-justification"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/text-justification/" rel="nofollow">Text Justification</a>
</h4>
<blockquote>
<p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
</blockquote>
<blockquote>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.</p>
</blockquote>
<blockquote>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
</blockquote>
<blockquote>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
**words**: ["This", "is", "an", "example", "of", "text", "justification."]
**L**: 16.
</code></pre>
<pre><code>Return the formatted lines as:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
</code></pre>
<blockquote>
<p><strong>Note</strong>: Each word is guaranteed not to exceed L in length.</p>
</blockquote>
<details><summary>Straightforward solution, needs to be very careful when coding</summary><p>
```swift
// Swift
class Solution {
    func fullJustify(_ words: [String], _ maxWidth: Int) -&gt; [String] {
		var res: [String] = []
		guard words.count &gt; 0 else { return res }
		guard maxWidth &gt; 0 else { return words }
		var words = words
</p>
<pre><code>	// Process words untile it's empty
	while words.isEmpty == false {
		let line = processOneLine(&amp;words, maxWidth)
		res.append(line)
	}
	
	return res
}

private func processOneLine(_ words: inout [String], _ maxWidth: Int) -&gt; String {
	guard words.count &gt; 0 else { return "" }
	
	var pendingWords: [String] = []
	var pendingWordsCount = 0
	while true {
		guard let nextWord = words.first else {
			// no more words to process, this is the last line, left justified
			// Clean trailing space
        	var lastWord = pendingWords.removeLast()
	        lastWord.characters.removeLast()
        	pendingWords.append(lastWord)
            pendingWordsCount -= 1
    
			let extraSpaces = maxWidth - pendingWordsCount
			var spaceString = ""
			for _ in 0..&lt;extraSpaces {
				spaceString += " "
			}
			return pendingWords.joined(separator: "") + spaceString
		}

		if pendingWordsCount + nextWord.characters.count &gt; maxWidth {
			// Cannot process next word, break and start to process this line
			break
		} else {
            // Include next words and continue
            pendingWords.append(nextWord + " ")
            words.removeFirst()
            pendingWordsCount += nextWord.characters.count + 1 // include space
        }
	}

    // Clean trailing space
	pendingWords[pendingWords.count - 1].characters.removeLast()
    pendingWordsCount -= 1
    
    // another way to clean trailing space
</code></pre>
<p>//		var lastWord = pendingWords.removeLast()
//		lastWord.characters.removeLast()
//		pendingWords.append(lastWord)</p>
<pre><code>    // ["a ", "b ", "c"]
    var extraSpaces = maxWidth - pendingWordsCount
    var insertIndex = 0
    while extraSpaces &gt; 0 {
        pendingWords[insertIndex] = pendingWords[insertIndex] + " "
        insertIndex += 1
        if pendingWords.count == 1 {
			insertIndex = 0
		} else {
			insertIndex = insertIndex % (pendingWords.count - 1) // last word has no space
		}
		extraSpaces -= 1
    }

    return pendingWords.joined(separator: "")
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)
&gt; 

&lt;details&gt;&lt;summary&gt;Solution Summary&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#reverse-words-in-a-string-ii" id="user-content-reverse-words-in-a-string-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/reverse-words-in-a-string-ii/" rel="nofollow">Reverse Words in a String II</a>
</h4>
<blockquote>
<p>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.</p>
</blockquote>
<blockquote>
<p>The input string does not contain leading or trailing spaces and the words are always separated by a single space.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given s = "the sky is blue",
return "blue is sky the".
</code></pre>
<blockquote>
<p>Could you do it in-place without allocating extra space?</p>
</blockquote>
<blockquote>
<p>Related problem: <a href="https://github.com/honghaoz/CrackingTheCodingInterview/wiki/Array#rotate-array">Rotate Array</a></p>
</blockquote>
<details><summary>Reverse each word then reverse the whole string</summary><p>
</p>
<div class="highlight highlight-source-java"><pre><span class="pl-c"><span class="pl-c">//</span> Java</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">reverseWords</span>(<span class="pl-k">char</span>[] <span class="pl-v">s</span>) {
        <span class="pl-c"><span class="pl-c">//</span> step1: reverse each word</span>
        <span class="pl-k">int</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> s<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
            <span class="pl-k">if</span> (s[i] <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>) {
                reverse(s, start, i);
                start <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>;
            }
            
            <span class="pl-c"><span class="pl-c">//</span> last word has no space</span>
            <span class="pl-k">if</span> (i <span class="pl-k">==</span> s<span class="pl-k">.</span>length <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
                reverse(s, start, i <span class="pl-k">+</span> <span class="pl-c1">1</span>);
            }
        }
        
        <span class="pl-c"><span class="pl-c">//</span> step2: reverse the whole string</span>
        reverse(s, <span class="pl-c1">0</span>, s<span class="pl-k">.</span>length);
    }
    
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">reverse</span>(<span class="pl-k">char</span>[] <span class="pl-v">s</span>, <span class="pl-k">int</span> <span class="pl-v">from</span>, <span class="pl-k">int</span> <span class="pl-v">to</span>) {
        <span class="pl-k">int</span> left <span class="pl-k">=</span> from;
        <span class="pl-k">int</span> right <span class="pl-k">=</span> to <span class="pl-k">-</span> <span class="pl-c1">1</span>;
        <span class="pl-k">while</span> (left <span class="pl-k">&lt;</span> right) {
            <span class="pl-k">char</span> temp <span class="pl-k">=</span> s[left];
            s[left] <span class="pl-k">=</span> s[right];
            s[right] <span class="pl-k">=</span> temp;
            
            left <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
            right <span class="pl-k">-=</span> <span class="pl-c1">1</span>;
        }
    }
}</pre></div>
<div class="highlight highlight-source-objc"><pre><span class="pl-c"><span class="pl-c">//</span> Objective-C</span>
+ (<span class="pl-k">void</span>)reverseWords:(<span class="pl-c1">NSMutableString</span> *)s
{
	<span class="pl-c"><span class="pl-c">//</span> step1: reverse each word</span>
	<span class="pl-c1">NSInteger</span> start = <span class="pl-c1">0</span>;
	<span class="pl-k">for</span> (<span class="pl-c1">NSInteger</span> i = <span class="pl-c1">0</span>; i &lt; s.<span class="pl-smi">length</span>; i++) {
		<span class="pl-k">if</span> ([[s <span class="pl-c1">substringWithRange:</span><span class="pl-c1">NSMakeRange</span>(i, <span class="pl-c1">1</span>)] <span class="pl-c1">isEqualTo:</span><span class="pl-s"><span class="pl-pds">@"</span> <span class="pl-pds">"</span></span>]) {
			[<span class="pl-c1">self</span> <span class="pl-c1">reverse:</span>s <span class="pl-c1">from:</span>start <span class="pl-c1">to:</span>i];
			start = i + <span class="pl-c1">1</span>;
		}
		
		<span class="pl-k">if</span> (i == s.<span class="pl-smi">length</span> - <span class="pl-c1">1</span>) {
			[<span class="pl-c1">self</span> <span class="pl-c1">reverse:</span>s <span class="pl-c1">from:</span>start <span class="pl-c1">to:</span>i + <span class="pl-c1">1</span>];
		}
	}
	
	<span class="pl-c"><span class="pl-c">//</span> step2: reverse the whole string</span>
	[<span class="pl-c1">self</span> <span class="pl-c1">reverse:</span>s <span class="pl-c1">from:</span><span class="pl-c1">0</span> <span class="pl-c1">to:</span>s.length];
}

+ (<span class="pl-k">void</span>)reverse:(<span class="pl-c1">NSMutableString</span> *)s from:(<span class="pl-c1">NSInteger</span>)from to:(<span class="pl-c1">NSInteger</span>)to
{
	<span class="pl-c1">NSInteger</span> left = from;
	<span class="pl-c1">NSInteger</span> right = to - <span class="pl-c1">1</span>;
	<span class="pl-k">while</span> (left &lt; right) {
		<span class="pl-c1">NSString</span> *temp = [s <span class="pl-c1">substringWithRange:</span><span class="pl-c1">NSMakeRange</span>(left, <span class="pl-c1">1</span>)];
		[s <span class="pl-c1">replaceCharactersInRange:</span><span class="pl-c1">NSMakeRange</span>(left, <span class="pl-c1">1</span>)
						 <span class="pl-c1">withString:</span>[s <span class="pl-c1">substringWithRange:</span><span class="pl-c1">NSMakeRange</span>(right, <span class="pl-c1">1</span>)]];
		[s <span class="pl-c1">replaceCharactersInRange:</span><span class="pl-c1">NSMakeRange</span>(right, <span class="pl-c1">1</span>)
						 <span class="pl-c1">withString:</span>temp];
		
		left += <span class="pl-c1">1</span>;
		right -= <span class="pl-c1">1</span>;
	}
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#add-strings" id="user-content-add-strings"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/add-strings/" rel="nofollow">Add Strings</a>
</h4>
<blockquote>
<p>Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2.</p>
</blockquote>
<blockquote>
<p>Note:</p>
</blockquote>
<ul>
<li>The length of both num1 and num2 is &lt; 5100.</li>
<li>Both num1 and num2 contains only digits 0-9.</li>
<li>Both num1 and num2 does not contain any leading zero.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ul>
<details><summary>Exceed Int limit solution</summary><p>
```swift
// Swift
// This can exceed limit of integer
class Solution {
    func addStrings(_ num1: String, _ num2: String) -&gt; String {
        return (num1.integerValue + num2.integerValue).stringValue ?? ""
    }
}
</p>
<p>extension String {
var integerValue: Int {
let chars = Array(self.characters.reversed())
var res = 0
for i in stride(from: chars.count - 1, to: -1, by: -1) {
let digit = Int(String(chars[i]))!
res = res * 10 + digit
}
return res
}
}</p>
<p>extension Int {
var stringValue: String? {
var reversedString = ""
var num = self
while num &gt; 0 {
let digit = num % 10
reversedString += "(digit)"
num /= 10
}
if reversedString.isEmpty {
return "0"
}
return String(reversedString.characters.reversed())
}
}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;Process each char and use carry to calculate sum&lt;/summary&gt;&lt;p&gt;
```swift
// Swift
class Solution {
    func addStrings(_ num1: String, _ num2: String) -&gt; String {
        let num1 = Array(num1.characters.reversed())
        let num2 = Array(num2.characters.reversed())
        
        var res = ""
        var carry = 0
        
        var i = 0
        while i &lt; num1.count &amp;&amp; i &lt; num2.count {
            let sum = Int(String(num1[i]))! + Int(String(num2[i]))! + carry
            let digit = sum % 10
            res += "\(digit)"
            
            carry = sum / 10
            i += 1
        }
        
        let num: [Character]
        if i &lt; num1.count {
            num = num1
        } else {
            num = num2
        }
        
        while i &lt; num.count {
            let sum = Int(String(num[i]))! + carry
            let digit = sum % 10
            res += "\(digit)"
            
            carry = sum / 10
            i += 1
        }
        
        if carry &gt; 0 {
            res += "\(carry)"
        }
        
        return String(res.characters.reversed())
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#multiply-strings" id="user-content-multiply-strings"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/multiply-strings/" rel="nofollow">Multiply Strings</a>
</h4>
<blockquote>
</blockquote>
<details><summary>Solution Summary</summary><p>
```swift
// Swift
```
</p></details>

        </div>

        <div class="wiki-footer gollum-markdown-content boxed-group" id="wiki-footer">
          <div class="boxed-group-inner wiki-auxiliary-content markdown-body">
            <p>我是有底线的</p>

          </div>
        </div>
    </div>]