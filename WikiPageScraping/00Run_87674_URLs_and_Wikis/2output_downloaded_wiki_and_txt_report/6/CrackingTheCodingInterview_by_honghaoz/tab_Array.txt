[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h2>
<a aria-hidden="true" class="anchor" href="#array-2430" id="user-content-array-2430"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Array [24/30]</h2>
<h1>
<a aria-hidden="true" class="anchor" href="#---title--difficulty" id="user-content----title--difficulty"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>| ✥ | Title | Difficulty</h1>
<p>:-:|:-:| :---- | :--------:
1 | ✅ | <a href="#summary-ranges">Summary Ranges</a> | Medium
2 | ✅ | <a href="#majority-element">Majority Element</a>| Easy
3 | ✅ | <a href="#majority-element-ii">Majority Element II</a>| Easy
4 | ✅ | <a href="#intersection-of-two-arrays">Intersection of Two Arrays</a>| Easy
5 | ✅ | <a href="#intersection-of-two-arrays-ii">Intersection of Two Arrays II</a> | Easy
6 | ✅ | <a href="#contains-duplicate">Contains Duplicate</a>| Easy
7 | ✅ | <a href="#contains-duplicate-ii">Contains Duplicate II</a>| Easy
8 | ✅ | <a href="#remove-duplicates-from-sorted-array">Remove Duplicates from Sorted Array</a>| Easy
9 | ✅ | <a href="#remove-duplicates-from-sorted-array-ii">Remove Duplicates from Sorted Array II</a>| Medium
10 | ✅ | <a href="#move-zeroes">Move Zeroes</a>| Easy
11 | ✅ | <a href="#remove-element">Remove Element</a>| Easy
12 | ✅ | <a href="#two-sum">Two Sum</a>| Easy
13 | ✅ | <a href="#3sum">3Sum</a>| Medium
14 | ✅ | <a href="#3sum-closest">3Sum Closest</a>| Medium
15 | ✅ | <a href="#4sum">4Sum</a>| Medium
16 | ✅ | <a href="#shortest-word-distance">Shortest Word Distance</a> | Easy
17 | ⚠️ | <a href="#shortest-word-distance-ii">Shortest Word Distance II</a> | Medium
18 | ✅ | <a href="#shortest-word-distance-iii">Shortest Word Distance III</a> | Medium
19 | ✅ | <a href="#maximum-size-subarray-sum-equals-k">Maximum Size Subarray Sum Equals k</a>| Easy
20 | ✅ | <a href="#product-of-array-except-self">Product of Array Except Self</a>| Medium
21 | ✅ | <a href="#rotate-array">Rotate Array</a>| Easy
22 | ✅ | <a href="#rotate-image">Rotate Image</a>| Medium
23 | ✅ | <a href="#spiral-matrix">Spiral Matrix</a>| Medium
24 | ✅ | <a href="#spiral-matrix-ii">Spiral Matrix II</a>| Medium
25 | ✅ | <a href="#valid-sudoku">Valid Sudoku</a>| Easy
26 | ✅ | <a href="#set-matrix-zeroes">Set Matrix Zeroes</a> | Medium
27 | ✅ | <a href="#next-permutation">Next Permutation</a> | Medium
28 | ✅ | <a href="#gas-station">Gas Station</a> | Medium
29 | ✅ | <a href="#sliding-window-maximum">Sliding Window Maximum</a>| Hard
30 | ✅ | <a href="#longest-consecutive-sequence">Longest Consecutive Sequence</a>| Hard</p>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#summary-ranges" id="user-content-summary-ranges"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/summary-ranges/" rel="nofollow">Summary Ranges</a>
</h4>
<blockquote>
<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given [0,1,2,4,5,7], return ["0-&gt;2","4-&gt;5","7"].
</code></pre>
<details><summary>Straight forward method</summary><p>
</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> Go through from left to right, if found any gaps (nums[i] - nums[i - 1] &gt; 1), construct a string and append it to `res`</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">summaryRanges</span>(<span class="pl-en">_</span> <span class="pl-smi">nums</span>: [<span class="pl-c1">Int</span>]) <span class="pl-k">-&gt;</span> [<span class="pl-c1">String</span>] {
        <span class="pl-k">var</span> res<span class="pl-k">:</span> [<span class="pl-c1">String</span>] <span class="pl-k">=</span> []
        
        <span class="pl-k">if</span> nums.<span class="pl-c1">count</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> {
            <span class="pl-k">return</span> res
        }
        
        <span class="pl-k">var</span> start <span class="pl-k">=</span> <span class="pl-c1">0</span> <span class="pl-c"><span class="pl-c">//</span> last start index</span>
<span class="pl-c"></span>        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span>nums.<span class="pl-c1">count</span> {
            <span class="pl-c"><span class="pl-c">//</span> if i is the last index, process and break</span>
<span class="pl-c"></span>            <span class="pl-k">if</span> i <span class="pl-k">==</span> nums.<span class="pl-c1">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span> {
                <span class="pl-k">if</span> start <span class="pl-k">==</span> i {
                    res.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">nums[i]</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
                }
                <span class="pl-k">else</span> {
                    res.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">nums[start]</span><span class="pl-pse"><span class="pl-s1">)</span></span>-&gt;<span class="pl-pse">\(</span><span class="pl-s1">nums[i]</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
                }
                <span class="pl-k">break</span>
            }
            
            <span class="pl-c"><span class="pl-c">//</span> No gap, continue</span>
<span class="pl-c"></span>            <span class="pl-k">if</span> nums[i <span class="pl-k">+</span> <span class="pl-c1">1</span>] <span class="pl-k">-</span> nums[i] <span class="pl-k">==</span> <span class="pl-c1">1</span> {
                <span class="pl-k">continue</span>
            }
            <span class="pl-c"><span class="pl-c">//</span> Process a new string and update start index</span>
<span class="pl-c"></span>            <span class="pl-k">else</span> {
                <span class="pl-k">if</span> start <span class="pl-k">==</span> i {
                    res.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">nums[i]</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
                }
                <span class="pl-k">else</span> {
                    res.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">nums[start]</span><span class="pl-pse"><span class="pl-s1">)</span></span>-&gt;<span class="pl-pse">\(</span><span class="pl-s1">nums[i]</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>)
                }
                start <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">1</span>
            }
        }
        
        <span class="pl-k">return</span> res
        
        <span class="pl-c"><span class="pl-c">//</span> [1] -&gt; "1"</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span> [1,3] -&gt; "1", "3"</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span> [1,2,3] -&gt; "1-&gt;3"</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span> [1,2,3,5,6,9] -&gt; "1-&gt;3", "5-&gt;6", "9"</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span>            s</span>
<span class="pl-c"></span>        <span class="pl-c"><span class="pl-c">//</span>            i</span>
<span class="pl-c"></span>    }
}</pre></div>
<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Foundation/Foundation.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">@interface</span> <span class="pl-en">Solution</span>: <span class="pl-e">NSObject</span>
  
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">summaryRange</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>;

<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Solution</span>
  
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">summaryRange</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>
{
    <span class="pl-c1">NSMutableArray</span> *res = [<span class="pl-c1">NSMutableArray</span> <span class="pl-c1">new</span>];
    
    <span class="pl-k">if</span> (nums.<span class="pl-smi">count</span> == <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> res;
    }
  
    <span class="pl-c1">NSInteger</span> start = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-c1">NSInteger</span> i = <span class="pl-c1">0</span>; i &lt; nums.<span class="pl-smi">count</span>; i++) {
        <span class="pl-k">if</span> (i == nums.<span class="pl-smi">count</span> - <span class="pl-c1">1</span>) {
            <span class="pl-k">if</span> (start == i) {
                [res <span class="pl-c1">addObject:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, nums[i]]];
            }
            <span class="pl-k">else</span> {
                [res <span class="pl-c1">addObject:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span>-&gt;<span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, nums[start], nums[i]]];
            }
            <span class="pl-k">break</span>;
        }
    
        <span class="pl-k">if</span> ([nums[i + <span class="pl-c1">1</span>] <span class="pl-c1">integerValue</span>] - [nums[i] <span class="pl-c1">integerValue</span>] == <span class="pl-c1">1</span>) {
            <span class="pl-k">continue</span>;
        }
        <span class="pl-k">else</span> {
            <span class="pl-k">if</span> (start == i) {
                [res <span class="pl-c1">addObject:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%ld</span><span class="pl-pds">"</span></span>, (<span class="pl-k">long</span>)[nums[i] <span class="pl-c1">integerValue</span>]]];
            }
            <span class="pl-k">else</span> {
                [res <span class="pl-c1">addObject:</span>[<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%ld</span>-&gt;<span class="pl-c1">%ld</span><span class="pl-pds">"</span></span>, (<span class="pl-k">long</span>)[nums[start] <span class="pl-c1">integerValue</span>], (<span class="pl-k">long</span>)[nums[i] <span class="pl-c1">integerValue</span>]]];
            }
            start = i + <span class="pl-c1">1</span>;
        }
    }
    <span class="pl-k">return</span> res;
}

<span class="pl-k">@end</span>

<span class="pl-k">int</span> <span class="pl-en">main</span> (<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> * argv[])
{
    @autoreleasepool {
        <span class="pl-c1">NSArray</span> *nums = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">2</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">5</span>, @<span class="pl-c1">6</span>, @<span class="pl-c1">8</span>];
        <span class="pl-c1">NSArray</span> *res = [Solution <span class="pl-c1">summaryRange:</span>nums];
        <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, res]);
    }
}</pre></div>
</details>
<details><summary>Functional Way</summary><p>
</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> 先go through numbers，在gap处插入separator (nums[0] - 1, because it's a sorted array, this is guaranteed to be a good separator)，然后split by separator，then process each segment</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">summaryRanges</span>(<span class="pl-en">_</span> <span class="pl-smi">nums</span>: [<span class="pl-c1">Int</span>]) <span class="pl-k">-&gt;</span> [<span class="pl-c1">String</span>] {
        <span class="pl-k">guard</span> nums.<span class="pl-c1">count</span> <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> <span class="pl-k">else</span> { <span class="pl-k">return</span> nums.<span class="pl-c1">map</span> { <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1"><span class="pl-c1">$0</span></span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span> } }
        
        <span class="pl-k">let</span> separator <span class="pl-k">=</span> nums[<span class="pl-c1">0</span>] <span class="pl-k">-</span> <span class="pl-c1">1</span>
        <span class="pl-k">var</span> processedNums<span class="pl-k">:</span> [<span class="pl-c1">Int</span>] <span class="pl-k">=</span> []
        <span class="pl-k">for</span> num <span class="pl-k">in</span> nums {
            <span class="pl-k">if</span> <span class="pl-k">let</span> lastNum <span class="pl-k">=</span> processedNums.<span class="pl-c1">last</span> {
                <span class="pl-k">if</span> num <span class="pl-k">-</span> lastNum <span class="pl-k">&gt;</span> <span class="pl-c1">1</span> {
                    processedNums.<span class="pl-c1">append</span>(separator)
                }
                processedNums.<span class="pl-c1">append</span>(num)
            } <span class="pl-k">else</span> {
                processedNums.<span class="pl-c1">append</span>(num)
            }
        }
        
        <span class="pl-k">let</span> segments <span class="pl-k">=</span> processedNums.<span class="pl-c1">split</span>(<span class="pl-c1">separator</span>: separator)
        <span class="pl-k">return</span> segments.<span class="pl-c1">map</span> { segment <span class="pl-k">-&gt;</span> <span class="pl-c1">String</span> <span class="pl-k">in</span>
            <span class="pl-k">guard</span> <span class="pl-k">let</span> first <span class="pl-k">=</span> segment.<span class="pl-c1">first</span>, <span class="pl-k">let</span> last <span class="pl-k">=</span> segment.<span class="pl-c1">last</span> <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
            }
            
            <span class="pl-k">if</span> first <span class="pl-k">==</span> last {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">first</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
            } <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">\(</span><span class="pl-s1">first</span><span class="pl-pse"><span class="pl-s1">)</span></span>-&gt;<span class="pl-pse">\(</span><span class="pl-s1">last</span><span class="pl-pse"><span class="pl-s1">)</span></span><span class="pl-pds">"</span></span>
            }
        }
    }
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#majority-element" id="user-content-majority-element"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/majority-element/" rel="nofollow">Majority Element</a>
</h4>
<blockquote>
<p>Given an array of size n, find the majority element.</p>
</blockquote>
<blockquote>
<p>The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
</blockquote>
<blockquote>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<details><summary>Use dictionary</summary><p>
```swift
// Use a dictionary to record num frequency
class Solution {
    func majorityElement(_ nums: [Int]) -&gt; Int {
        var numCount: [Int : Int] = [:]
        var major: Int = nums[0]
        nums.forEach {
            if let count = numCount[$0] {
                numCount[$0] = count + 1
                if count + 1 &gt; nums.count / 2 {
                    major = $0
                }
            } else {
                numCount[$0] = 1
            }
        }
</p>
<pre><code>    return major
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
#import &lt;Foundation/Foundation.h&gt;
#import &lt;stdio.h&gt;

@interface Solution: NSObject
+ (NSInteger)majorityElement:(NSArray *)nums;
@end

@implementation Solution
+ (NSInteger)majorityElement:(NSArray *)nums
{
	NSMutableDictionary *numsCount = [NSMutableDictionary new];
	NSInteger major = [nums[0] integerValue];
	
	for (NSNumber *num in nums) {
		numsCount[num] = ([numsCount objectForKey:num] == nil) ? @1 : @([numsCount[num] integerValue] + 1);
		if ([numsCount[num] integerValue] &gt; (nums.count / 2)) {
			major = [num integerValue];
			break;
		}
	}
	
	return major;
}
@end

// Main
int main(int argc, const char * argv[]) {
	@autoreleasepool {
		NSArray *nums = @[@1, @3, @3, @3, @5];
		NSInteger res = [Solution majorityElement:nums];
		NSLog(@"%@", [NSString stringWithFormat:@"%ld", (long)res]);
	}
	return 0;
}
</code></pre>
</details>
<details><summary>Use Count</summary><p>
</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> A better solution, just use a count</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">majorityElement</span>(<span class="pl-en">_</span> <span class="pl-smi">nums</span>: [<span class="pl-c1">Int</span>]) <span class="pl-k">-&gt;</span> <span class="pl-c1">Int</span> {
        <span class="pl-k">if</span> nums.<span class="pl-c1">count</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> {
            <span class="pl-c"><span class="pl-c">//</span> never goes here</span>
<span class="pl-c"></span>            <span class="pl-k">return</span> <span class="pl-c1">0</span>
        }
        
        <span class="pl-k">var</span> count <span class="pl-k">=</span> <span class="pl-c1">1</span>
        <span class="pl-k">var</span> major <span class="pl-k">=</span> nums[<span class="pl-c1">0</span>]
        
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span><span class="pl-k">..&lt;</span>nums.<span class="pl-c1">count</span> {
            <span class="pl-k">if</span> nums[i] <span class="pl-k">==</span> major {
                count <span class="pl-k">+=</span> <span class="pl-c1">1</span>
            } <span class="pl-k">else</span> {
                count <span class="pl-k">-=</span> <span class="pl-c1">1</span>
            }
            
            <span class="pl-k">if</span> count <span class="pl-k">==</span> <span class="pl-c1">0</span> {
                major <span class="pl-k">=</span> nums[i]
                count <span class="pl-k">=</span> <span class="pl-c1">1</span>
            }
        }
        
        <span class="pl-k">return</span> major
    }
}</pre></div>
<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Foundation/Foundation.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">@interface</span> <span class="pl-en">Solution</span>: <span class="pl-e">NSObject</span>
  
+ (<span class="pl-c1">NSInteger</span>)<span class="pl-en">majorityElement</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>;

<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Solution</span>
  
+ (<span class="pl-c1">NSInteger</span>)<span class="pl-en">majorityElement</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>
{
    <span class="pl-k">if</span> (nums.<span class="pl-smi">count</span> == <span class="pl-c1">0</span>) {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
    }
    
    <span class="pl-c1">NSInteger</span> count = <span class="pl-c1">1</span>;
    <span class="pl-c1">NSInteger</span> <span class="pl-c1">major</span> = [nums[<span class="pl-c1">0</span>] <span class="pl-c1">integerValue</span>];
    
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">1</span>; i &lt; nums.<span class="pl-smi">count</span>; i++) {
        <span class="pl-k">if</span> ([nums[i] <span class="pl-c1">integerValue</span>] == <span class="pl-c1">major</span>) {
            count += <span class="pl-c1">1</span>;
        }
        <span class="pl-k">else</span> {
            count -= <span class="pl-c1">1</span>;
        }
        
        <span class="pl-k">if</span> (count == <span class="pl-c1">0</span>) {
            <span class="pl-c1">major</span> = [nums[i] <span class="pl-c1">integerValue</span>];
            count = <span class="pl-c1">1</span>;
        }
    }
    
    <span class="pl-k">return</span> <span class="pl-c1">major</span>;
}

<span class="pl-k">@end</span>

<span class="pl-k">int</span> <span class="pl-en">main</span> (<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> * argv[])
{
    @autoreleasepool {
        <span class="pl-c1">NSArray</span> *nums = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">2</span>, @<span class="pl-c1">2</span>, @<span class="pl-c1">2</span>, @<span class="pl-c1">6</span>, @<span class="pl-c1">8</span>];
        <span class="pl-c1">NSInteger</span> res = [Solution <span class="pl-c1">majorityElement:</span>nums];
        <span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%ld</span><span class="pl-pds">"</span></span>, (<span class="pl-k">long</span>)res]);
    }
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#majority-element-ii" id="user-content-majority-element-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/majority-element-ii/" rel="nofollow">Majority Element II</a>
</h4>
<blockquote>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
</blockquote>
<details><summary>Use 2 Count</summary><p>
```swift
// Since there are at most 2 major elements, use two `count`s and `major`s to record majors, and needs to verify those potential majors are actually majors. 
class Solution {
    func majorityElement(_ nums: [Int]) -&gt; [Int] {
        var count1 = 0
        var count2 = 0
        var major1: Int?
        var major2: Int?
</p>
<pre><code>    for num in nums {
        if let major1 = major1, major1 == num {
            count1 += 1
        }
        else if let major2 = major2, major2 == num {
            count2 += 1
        }
        else if count1 == 0 {
            major1 = num
            count1 += 1
        }
        else if count2 == 0 {
            major2 = num
            count2 += 1
        }
        else {
            count1 -= 1
            count2 -= 1
        }
    }
    
    count1 = 0
    count2 = 0
    for num in nums {
        if num == major1 {
            count1 += 1
        }
        else if num == major2 {
            count2 += 1
        }
    }
    
    var res = [Int]()
    if count1 &gt; nums.count / 3 {
        res.append(major1!)
    }
    if count2 &gt; nums.count / 3 {
        res.append(major2!)
    }
    
    return res
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;


*****************************************************************************************************************
#### [Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)
&gt; Given two arrays, write a function to compute their intersection.

&gt; 
</code></pre>
<p>Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p>
<pre><code>
&gt; Note:
&gt; - Each element in the result must be unique.
&gt; - The result can be in any order.

&lt;details&gt;&lt;summary&gt;Use Set&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func intersection(_ nums1: [Int], _ nums2: [Int]) -&gt; [Int] {
        var results = Set&lt;Int&gt;()
		
		for num1 in nums1 {
			for num2 in nums2 {
				if num1 == num2 {
					results.insert(num1)
				}
			}
		}
		
		return Array(results)
    }
}
</code></pre>
<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Foundation/Foundation.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">@interface</span> <span class="pl-en">Solution</span>: <span class="pl-e">NSObject</span>
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">intersection</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums1</span> <span class="pl-en">with</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums2</span>;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Solution</span>
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">intersection</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums1</span> <span class="pl-en">with</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums2</span>
{
	<span class="pl-c1">NSMutableSet</span> *res = [<span class="pl-c1">NSMutableSet</span> <span class="pl-c1">new</span>];
	
	<span class="pl-k">for</span> (<span class="pl-c1">NSNumber</span> *num1 in nums1) {
		<span class="pl-k">for</span> (<span class="pl-c1">NSNumber</span> *num2 in nums2) {
			<span class="pl-k">if</span> (num1 == num2) {
				[res <span class="pl-c1">addObject:</span>num1];
			}
		}
	}
	
	<span class="pl-k">return</span> [res <span class="pl-c1">allObjects</span>];
}
<span class="pl-k">@end</span>

<span class="pl-c"><span class="pl-c">//</span> Main</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> * argv[]) {
	@autoreleasepool {
		<span class="pl-c1">NSArray</span> *nums1 = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">5</span>];
		<span class="pl-c1">NSArray</span> *nums2 = @[@<span class="pl-c1">2</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">6</span>];
		<span class="pl-c1">NSArray</span> *res = [Solution <span class="pl-c1">intersection:</span>nums1 <span class="pl-c1">with:</span>nums2];
		<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, res]);
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
</details>
<details><summary>Set Intersection</summary><p>
```swift
class Solution {
    func intersection(_ nums1: [Int], _ nums2: [Int]) -&gt; [Int] {
        return Array(Set(nums1).intersection(Set(nums2)))
    }
}
```
</p>
<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Foundation/Foundation.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">@interface</span> <span class="pl-en">Solution</span>: <span class="pl-e">NSObject</span>
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">intersection</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums1</span> <span class="pl-en">with</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums2</span>;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Solution</span>
+ (<span class="pl-c1">NSArray</span> *)<span class="pl-en">intersection</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums1</span> <span class="pl-en">with</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums2</span>
{
	<span class="pl-c1">NSMutableSet</span> *set1 = [[<span class="pl-c1">NSMutableSet</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithArray:</span>nums1];
	<span class="pl-c1">NSSet</span> *set2 = [[<span class="pl-c1">NSSet</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithArray:</span>nums2];
	
	[set1 <span class="pl-c1">intersectSet:</span>set2];
	<span class="pl-k">return</span> [set1 <span class="pl-c1">allObjects</span>];
}
<span class="pl-k">@end</span>

<span class="pl-c"><span class="pl-c">//</span> Main</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> * argv[]) {
	@autoreleasepool {
		<span class="pl-c1">NSArray</span> *nums1 = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">5</span>];
		<span class="pl-c1">NSArray</span> *nums2 = @[@<span class="pl-c1">2</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">6</span>];
		<span class="pl-c1">NSArray</span> *res = [Solution <span class="pl-c1">intersection:</span>nums1 <span class="pl-c1">with:</span>nums2];
		<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, [<span class="pl-c1">NSString</span> <span class="pl-c1">stringWithFormat:</span><span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, res]);
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#intersection-of-two-arrays-ii" id="user-content-intersection-of-two-arrays-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" rel="nofollow">Intersection of Two Arrays II</a>
</h4>
<blockquote>
<p>Given two arrays, write a function to compute their intersection.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].
</code></pre>
<blockquote>
<p>Note:</p>
</blockquote>
<blockquote>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>The result can be in any order.</li>
</ul>
</blockquote>
<blockquote>
<p>Follow up:</p>
</blockquote>
<blockquote>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>What if nums1's size is small compared to nums2's size? Which algorithm is better?</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
</blockquote>
<details><summary>Iterate two arrays, remove both if equal</summary><p>
```swift
class Solution {
    func intersect(_ nums1: [Int], _ nums2: [Int]) -&gt; [Int] {
        var mutableNums1 = nums1
		var mutableNums2 = nums2
		var results: [Int] = []
</p>
<pre><code>	var i = 0
	while i &lt; mutableNums1.count {
		for j in 0 ..&lt; mutableNums2.count {
			if mutableNums1[i] == mutableNums2[j] {
				results.append(mutableNums1[i])
				mutableNums1.remove(at: i)
				mutableNums2.remove(at: j)
				i -= 1
				break
			}
		}
		i += 1
	}
	
	return results
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;Sort then use two pointers to check&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func intersect(_ nums1: [Int], _ nums2: [Int]) -&gt; [Int] {
        var res = [Int]()
        
        if nums1.count == 0 || nums2.count == 0 {
            return res
        }
        
        let nums1 = nums1.sorted()
        let nums2 = nums2.sorted()
        
        var i = 0
        var j = 0
        while i &lt; nums1.count &amp;&amp; j &lt; nums2.count {
            if nums1[i] &lt; nums2[j] {
                i += 1
            }
            else if nums1[i] &gt; nums2[j] {
                j += 1
            }
            else {
                res.append(nums1[i])
                i += 1
                j += 1
            }
        }
        
        return res
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#contains-duplicate" id="user-content-contains-duplicate"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/contains-duplicate/" rel="nofollow">Contains Duplicate</a>
</h4>
<blockquote>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
</blockquote>
<details><summary>Use dictionary to check</summary><p>
```swift
class Solution {
    func containsDuplicate(_ nums: [Int]) -&gt; Bool {
        var hash: [Int : Int] = [:]
		for num in nums {
			if hash[num] == nil {
				hash[num] = 0
			} else {
				return true
			}
		}
</p>
<pre><code>	return false
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
#import &lt;Foundation/Foundation.h&gt;
#import &lt;stdio.h&gt;

@interface Solution: NSObject
+ (BOOL)containsDuplicate:(NSArray *)nums;
@end

@implementation Solution
+ (BOOL)containsDuplicate:(NSArray *)nums
{
	NSMutableDictionary *hash = [[NSMutableDictionary alloc] init];
	for (NSNumber *num in nums) {
		if (hash[num] != nil) {
			return YES;
		}
		else {
			hash[num] = @0;
		}
	}
	
	return NO;
}
@end

// Main
int main(int argc, const char * argv[]) {
	@autoreleasepool {
		NSArray *nums = @[@1, @3, @3, @3, @5];
		BOOL res = [Solution containsDuplicate:nums];
		NSLog(@"%@", res ? @"YES" : @"NO");
	}
	return 0;
}
</code></pre>
</details>
<details><summary>Compare set.count with array.count</summary><p>
```swift
class Solution {
    func containsDuplicate(_ nums: [Int]) -&gt; Bool {
        return Set(nums).count &lt; nums.count
    }
}
```
</p>
<div class="highlight highlight-source-objc"><pre>#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Foundation/Foundation.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">@interface</span> <span class="pl-en">Solution</span>: <span class="pl-e">NSObject</span>
+ (<span class="pl-c1">BOOL</span>)<span class="pl-en">containsDuplicate</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>;
<span class="pl-k">@end</span>

<span class="pl-k">@implementation</span> <span class="pl-en">Solution</span>
+ (<span class="pl-c1">BOOL</span>)<span class="pl-en">containsDuplicate</span><span class="pl-en">:</span>(<span class="pl-c1">NSArray</span> *)<span class="pl-smi">nums</span>
{
	<span class="pl-c1">NSSet</span> *set = [[<span class="pl-c1">NSSet</span> <span class="pl-c1">alloc</span>] <span class="pl-c1">initWithArray:</span>nums];
	<span class="pl-k">return</span> set.<span class="pl-smi">count</span> &lt; nums.<span class="pl-smi">count</span>;
}
<span class="pl-k">@end</span>

<span class="pl-c"><span class="pl-c">//</span> Main</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">const</span> <span class="pl-k">char</span> * argv[]) {
	@autoreleasepool {
		<span class="pl-c1">NSArray</span> *nums = @[@<span class="pl-c1">1</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">3</span>, @<span class="pl-c1">5</span>];
		<span class="pl-c1">BOOL</span> res = [Solution <span class="pl-c1">containsDuplicate:</span>nums];
		<span class="pl-c1">NSLog</span>(<span class="pl-s"><span class="pl-pds">@"</span><span class="pl-c1">%@</span><span class="pl-pds">"</span></span>, res ? <span class="pl-s"><span class="pl-pds">@"</span>YES<span class="pl-pds">"</span></span> : <span class="pl-s"><span class="pl-pds">@"</span>NO<span class="pl-pds">"</span></span>);
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#contains-duplicate-ii" id="user-content-contains-duplicate-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/contains-duplicate-ii/" rel="nofollow">Contains Duplicate II</a>
</h4>
<blockquote>
<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
</blockquote>
<details><summary>Use a dictionary to record last index</summary><p>
```swift
class Solution {
    func containsNearbyDuplicate(_ nums: [Int], _ k: Int) -&gt; Bool {
        var hash: [Int : Int] = [:] // key: num, value: lastIndex
        for i in 0..<code>#import &lt;Foundation/Foundation.h&gt;
#import &lt;stdio.h&gt;

@interface Solution: NSObject
+ (void)run;
@end

@implementation Solution
+ (void)run
{
	NSArray *nums = @[@1, @3, @2, @1, @3, @5];
	NSInteger k = 2;
	assert([self containsNearbyDuplicate:nums withK:k] == NO);
	
	k = 3;
	assert([self containsNearbyDuplicate:nums withK:k] == YES);
}

+ (BOOL)containsNearbyDuplicate:(NSArray *)nums withK:(NSInteger)k
{
	NSMutableDictionary *hash = [NSMutableDictionary new];
	for (NSInteger i = 0; i &lt; nums.count; i++) {
		if (hash[nums[i]] != nil) {
			if (i - [hash[nums[i]] integerValue] &lt;= k) {
				return YES;
			}
		}
		hash[nums[i]] = [NSNumber numberWithInteger:i];
	}
	return NO;
}

@end

// Main
int main(int argc, const char * argv[]) {
	@autoreleasepool {
		[Solution run];
	}
	return 0;
}
</code>
</p></details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#remove-duplicates-from-sorted-array" id="user-content-remove-duplicates-from-sorted-array"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" rel="nofollow">Remove Duplicates from Sorted Array</a>
</h4>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
</blockquote>
<blockquote>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given input array nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.
</code></pre>
<details><summary>Use `lastIndex` to check</summary><p>
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -&gt; Int {
		guard nums.count &gt; 0 else {
			return 0
		}
</p>
<pre><code>	var lastIndex: Int = 0
	for num in nums {
		if nums[lastIndex] != num {
			lastIndex += 1
			nums[lastIndex] = num
		}
	}
	
	return lastIndex + 1
}
</code></pre>
<p>}</p>
<pre><code>
```swift
// A cleaner solution
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -&gt; Int {
		var lastIndex = -1
		for i in 0..&lt;nums.count {
		    if lastIndex == -1 || nums[lastIndex] != nums[i] {
		        lastIndex += 1
		        nums[lastIndex] = nums[i]
		    }
		}
		return lastIndex + 1
	}
}
</code></pre>
<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-c1">NSInteger</span>)removeDuplicates:(<span class="pl-c1">NSMutableArray</span> *)nums
{
	<span class="pl-c1">NSInteger</span> lastIndex = -<span class="pl-c1">1</span>;
	<span class="pl-k">for</span> (<span class="pl-c1">NSInteger</span> i = <span class="pl-c1">0</span>; i &lt; nums.<span class="pl-smi">count</span>; i++) {
		<span class="pl-c"><span class="pl-c">//</span> if not equal, move lastIndex and update nums</span>
		<span class="pl-k">if</span> (lastIndex == -<span class="pl-c1">1</span> || nums[lastIndex] != nums[i]) {
			lastIndex += <span class="pl-c1">1</span>;
			nums[lastIndex] = nums[i];
		}
	}
	<span class="pl-k">return</span> lastIndex + <span class="pl-c1">1</span>;
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#remove-duplicates-from-sorted-array-ii" id="user-content-remove-duplicates-from-sorted-array-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" rel="nofollow">Remove Duplicates from Sorted Array II</a>
</h4>
<blockquote>
<p>Follow up for "Remove Duplicates":</p>
</blockquote>
<blockquote>
<p>What if duplicates are allowed at most twice?</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given sorted array nums = [1,1,1,2,2,3],
Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.
</code></pre>
<details><summary>Use two indices to record, just compare first index with current num</summary><p>
```swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -&gt; Int {
        guard nums.count &gt; 2 else {
		return nums.count
	}
</p>
<pre><code>var lastIndex1: Int = 0
var lastIndex2: Int = 1
	
for i in 2 ..&lt; nums.count {
	if nums[i] != nums[lastIndex1] {
		lastIndex1 += 1
		lastIndex2 += 1
		nums[lastIndex2] = nums[i]
	}
}
	
return lastIndex2 + 1
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
+ (NSInteger)removeDuplicates:(NSMutableArray *)nums
{
	if (nums.count &lt;= 2) {
		return nums.count;
	}
	
	NSInteger lastIndex1 = 0;
	NSInteger lastIndex2 = 1;
	
	for (NSInteger i = 2; i &lt; nums.count; i++) {
		if (nums[i] != nums[lastIndex1]) {
			lastIndex1 += 1;
			lastIndex2 += 1;
			nums[lastIndex2] = nums[i];
		}
	}
	return lastIndex2 + 1;
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#move-zeroes" id="user-content-move-zeroes"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/move-zeroes/" rel="nofollow">Move Zeroes</a>
</h4>
<blockquote>
<p>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
</code></pre>
<blockquote>
<p>Note:</p>
<ul>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ul>
</blockquote>
<details><summary>Use last non zero index</summary><p>
```swift
class Solution {
    func moveZeroes(_ nums: inout [Int]) {
        guard nums.count &gt; 0 else { return }
        var lastNonZeroIndex: Int = -1
</p>
<pre><code>    for i in 0..&lt;nums.count {
        let num = nums[i]
        if num == 0 {
            continue
        } else {
            lastNonZeroIndex += 1
            nums[lastNonZeroIndex] = num
        }
    }
    
    while lastNonZeroIndex + 1 &lt; nums.count {
        lastNonZeroIndex += 1
        nums[lastNonZeroIndex] = 0
    }
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
+ (void)moveZeroes:(NSMutableArray *)nums
{
	if (nums.count == 0) {
		return;
	}
	NSInteger lastIndex = -1;
	
	for (NSInteger i = 0; i &lt; nums.count; i++) {
		if ([nums[i] integerValue] == 0) {
			continue;
		}
		else {
			lastIndex += 1;
			nums[lastIndex] = nums[i];
		}
	}
	
	// [1,2,3, -, -, -]
	//         |
	lastIndex += 1;
	while (lastIndex &lt; nums.count) {
		nums[lastIndex] = @0;
		lastIndex += 1;
	}
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#remove-element" id="user-content-remove-element"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/remove-element/" rel="nofollow">Remove Element</a>
</h4>
<blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
</blockquote>
<blockquote>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
</blockquote>
<blockquote>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Example:
Given input array nums = [3,2,2,3], val = 3
Your function should return length = 2, with the first two elements of nums being 2.
</code></pre>
<blockquote>
<p>Hint:</p>
<ul>
<li>Try two pointers.</li>
<li>Did you use the property of "the order of elements can be changed"?</li>
<li>What happens when the elements to remove are rare?</li>
</ul>
</blockquote>
<details><summary>Like remove zero</summary><p>
```swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int {
        // guard nums.count &gt; 0 else { return 0 }
        var lastNonValueIndex = -1
        for i in 0..<code>    return lastNonValueIndex + 1
}
</code>
</p>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Two Sum](https://leetcode.com/problems/two-sum/)

&gt; Given an array of integers, return indices of the two numbers such that they add up to a specific target.

&gt; You may assume that each input would have exactly one solution.

&gt; 
</code></pre>
<p>Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].</p>
<pre><code>
&gt; UPDATE (2016/2/13):
&gt; The return format had been changed to zero-based indices. Please read the above updated description carefully.

&lt;details&gt;&lt;summary&gt;Use dictionary to store number-&gt;index, find target index&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {
        var numToIndex: [Int : Int] = [:]
        for i in 0..&lt;nums.count {
            let numToFind = target - nums[i]
            if let indexToFind = numToIndex[numToFind] {
                return [indexToFind, i]
            } else {
                numToIndex[nums[i]] = i
            }
        }
        return []
    }
}
</code></pre>
<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-c1">NSArray</span> *)twoSum:(<span class="pl-c1">NSArray</span> *)nums withTarget:(<span class="pl-c1">NSInteger</span>)target
{
	<span class="pl-c1">NSMutableDictionary</span> *dict = [<span class="pl-c1">NSMutableDictionary</span> <span class="pl-c1">new</span>];
	<span class="pl-k">for</span> (<span class="pl-c1">NSInteger</span> i = <span class="pl-c1">0</span>; i &lt; nums.<span class="pl-smi">count</span>; i++)
	{
		<span class="pl-c1">NSNumber</span> *toFind = @(target - [nums[i] <span class="pl-c1">integerValue</span>]);
		<span class="pl-k">if</span> (dict[toFind] != <span class="pl-c1">nil</span>)
		{
			<span class="pl-k">return</span> @[dict[toFind], @(i)];
		}
		<span class="pl-k">else</span>
		{
			dict[nums[i]] = @(i);
		}
	}
	<span class="pl-k">return</span> @[];
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#3sum" id="user-content-3sum"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/3sum/" rel="nofollow">3Sum</a>
</h4>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
</blockquote>
<blockquote>
<p>Note: The solution set must not contain duplicate triplets.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre>
<details><summary>Iterate from 0 to count - 1, use two pointers to find results, skip if equals</summary><p>
```swift
class Solution {
    func threeSum(_ nums: [Int]) -&gt; <a class="internal absent" href="/honghaoz/CrackingTheCodingInterview/wiki/Int">Int</a> {
        var results: <a class="internal absent" href="/honghaoz/CrackingTheCodingInterview/wiki/Int">Int</a> = []
		guard nums.count &gt;= 3 else { return results }
		let nums = nums.sorted()
</p>
<pre><code>	let target = 0
	for i in 0..&lt;(nums.count) {
		// Try first element, but skip duplicated nums
		if i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] {
			continue
		}
		
		var j = i + 1
		var k = nums.count - 1
		while j &lt; k {
			if nums[i] + nums[j] + nums[k] == target {
				results.append([nums[i], nums[j], nums[k]])
				j += 1
				while nums[j] == nums[j - 1] &amp;&amp; j &lt; k {
					j += 1
				}
				
				k -= 1
				while nums[k] == nums[k + 1] &amp;&amp; j &lt; k {
					k -= 1
				}
			}
			else if nums[i] + nums[j] + nums[k] &lt; target {
				j += 1
				while nums[j] == nums[j - 1] &amp;&amp; j &lt; k {
					j += 1
				}
			}
			else {
				k -= 1
				while nums[k] == nums[k + 1] &amp;&amp; j &lt; k {
					k -= 1
				}
			}
		}
	}
	
	return results
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
+ (NSArray *)threeSum:(NSArray *)nums
{
	NSArray *sortedNums = [nums sortedArrayUsingSelector:@selector(compare:)];
	NSMutableArray *res = [NSMutableArray new];
	for (NSInteger i = 0; i &lt; sortedNums.count; i++)
	{
		if (i != 0 &amp;&amp; sortedNums[i] == sortedNums[i - 1])
		{
			continue;
		}
		
		NSInteger left = i + 1;
		NSInteger right = sortedNums.count - 1;
		while (left &lt; right)
		{
			NSInteger target = 0 - [sortedNums[i] integerValue];
			NSInteger leftNumber = [sortedNums[left] integerValue];
			NSInteger rightNumber = [sortedNums[right] integerValue];
			if (leftNumber + rightNumber &lt; target) {
				left += 1;
				while (sortedNums[left] == sortedNums[left - 1] &amp;&amp; left &lt; right) {
					left += 1;
				}
			}
			else if (leftNumber + rightNumber &gt; target) {
				right -= 1;
				while (sortedNums[right] == sortedNums[right + 1] &amp;&amp; left &lt; right) {
					right -= 1;
				}
			}
			else {
				[res addObject:@[sortedNums[i], sortedNums[left], sortedNums[right]]];
				left += 1;
				while (sortedNums[left] == sortedNums[left - 1] &amp;&amp; left &lt; right) {
					left += 1;
				}
				right -= 1;
				while (sortedNums[right] == sortedNums[right + 1] &amp;&amp; left &lt; right) {
					right -= 1;
				}
			}
		}
	}
	return res;
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#3sum-closest" id="user-content-3sum-closest"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/3sum-closest/" rel="nofollow">3Sum Closest</a>
</h4>
<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>
<details><summary>Iterate and use two pointers, make sure set initial result</summary><p>
```swift
class Solution {
    func threeSumClosest(_ nums: [Int], _ target: Int) -&gt; Int {
        var result: Int = 0
		guard nums.count &gt; 2 else { return result } // question to ask
		let nums = nums.sorted()
</p>
<pre><code>	for i in 0..&lt;(nums.count) {
		if i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] { continue }
		
		var j = i + 1
		var k = nums.count - 1
		
		// set initial value
		if i == 0 {
			result = nums[i] + nums[j] + nums[k]
			if result == target {
				return result
			}
		}
		
		while j &lt; k {
			let newSum = nums[i] + nums[j] + nums[k]
			if abs(newSum - target) &lt; abs(result - target) {
				result = newSum
			}
			
			if newSum &lt; target {
				j += 1
				while nums[j] == nums[j - 1] &amp;&amp; j &lt; k {
					j += 1
				}
			}
			else if newSum &gt; target {
				k -= 1
				while nums[k] == nums[k + 1] &amp;&amp; j &lt; k {
					k -= 1
				}
			}
			else {
				result = target
				break
			}
		}
	}
	
	return result
}
</code></pre>
<p>}</p>
<pre><code>
&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [4Sum](https://leetcode.com/problems/4sum/)

&gt; Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

&gt; **Note**: The solution set must not contain duplicate quadruplets.

&gt;
</code></pre>
<p>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.
A solution set is:
[
[-1,  0, 0, 1],
[-2, -1, 1, 2],
[-2,  0, 0, 2]
]</p>
<pre><code>
&lt;details&gt;&lt;summary&gt;One extra iteration on 3Sum&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func fourSum(_ nums: [Int], _ target: Int) -&gt; [[Int]] {
        var results: [[Int]] = []
        guard nums.count &gt; 3 else { return results }
        
        let nums = nums.sorted()
        for i in 0..&lt;(nums.count) {
            if i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] { continue }
            for j in (i + 1)..&lt;(nums.count) {
                if j &gt; (i + 1) &amp;&amp; nums[j] == nums[j - 1] { continue }
                var a = j + 1
                var b = nums.count - 1
                while a &lt; b {
                    let newSum = nums[i] + nums[j] + nums[a] + nums[b]
                    if newSum &lt; target {
                        a += 1
                        while nums[a] == nums[a - 1] &amp;&amp; a &lt; b {
                            a += 1
                        }
                    }
                    else if newSum &gt; target {
                        b -= 1
                        while nums[b] == nums[b + 1] &amp;&amp; a &lt; b {
                            b -= 1
                        }
                    }
                    else {
                        results.append([nums[i], nums[j], nums[a], nums[b]])
                        a += 1
                        b -= 1
                        while nums[a] == nums[a - 1] &amp;&amp; a &lt; b {
                            a += 1
                        }
                        while nums[b] == nums[b + 1] &amp;&amp; a &lt; b {
                            b -= 1
                        }
                    }
                }
            }
        }
        
        return results
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#shortest-word-distance" id="user-content-shortest-word-distance"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/shortest-word-distance" rel="nofollow">Shortest Word Distance</a>
</h4>
<blockquote>
<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
Given word1 = “coding”, word2 = “practice”, return 3.
Given word1 = "makes", word2 = "coding", return 1.
</code></pre>
<blockquote>
<p><strong>Note</strong>: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
</blockquote>
<details><summary>Use to indices to record last appeared index, record min distance</summary><p>
```swift
class Solution {
    func shortestDistance(_ words: [String], _ word1: String, _ word2: String) -&gt; Int {
        var index1 = -1
        var index2 = -1
        var res = Int.max
</p>
<pre><code>    for i in 0..&lt;words.count {
        if words[i] == word1 {
            index1 = i
        }
        if words[i] == word2 {
            index2 = i
        }
        if index1 != -1 &amp;&amp; index2 != -1 {
            res = min(res, abs(index1 - index2))
        }
    }
    return res
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
+ (NSInteger)shortestDistance:(NSArray *)words word1:(NSString *)word1 word2:(NSString *)word2
{
	NSInteger index1 = -1;
	NSInteger index2 = -1;
	NSInteger res = INT_MAX;
	
	for (NSInteger i = 0; i &lt; words.count; i++) {
		if ([words[i] isEqualTo:word1]) {
			index1 = i;
		}
		if ([words[i] isEqualTo:word2]) {
			index2 = i;
		}
		if (index1 != -1 &amp;&amp; index2 != -1) {
			res = MIN(res, labs(index1 - index2));
		}
	}
	return res;
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#shortest-word-distance-ii" id="user-content-shortest-word-distance-ii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/shortest-word-distance-ii" rel="nofollow">Shortest Word Distance II</a>
</h4>
<blockquote>
<p>This is a <strong>follow up</strong> of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p>
</blockquote>
<blockquote>
<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
Given word1 = “coding”, word2 = “practice”, return 3.
Given word1 = "makes", word2 = "coding", return 1.
</code></pre>
<blockquote>
<p><strong>Note</strong>:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
</blockquote>
<details><summary>Use a hash map to store indices for words, calculate the minimum distance from two arrays using two pointers</summary><p>
```swift
// TODO
```
</p></details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#shortest-word-distance-iii" id="user-content-shortest-word-distance-iii"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/shortest-word-distance-iii" rel="nofollow">Shortest Word Distance III</a>
</h4>
<blockquote>
<p>This is a <strong>follow up</strong> of Shortest Word Distance. The only difference is now word1 could be the same as word2.</p>
</blockquote>
<blockquote>
<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
</blockquote>
<blockquote>
<p><em>word1</em> and <em>word2</em> may be the same and they represent two individual words in the list.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
Given word1 = “makes”, word2 = “coding”, return 1.
Given word1 = "makes", word2 = "makes", return 3.
</code></pre>
<blockquote>
<p><strong>Note</strong>:
You may assume word1 and word2 are both in the list.</p>
</blockquote>
<details><summary>Same process for word1 == word2, if equals, use extra `lastChanged` variable to help alternately updating index1 and index2 (用一个辅助变量记录上一次更改过的index，来交替update index)</summary><p>
```swift
class Solution {
    func shortestWordDistance(_ words: [String], _ word1: String, _ word2: String) -&gt; Int {
        var index1 = -1
        var index2 = -1
        var res = Int.max
</p>
<pre><code>    if word1 == word2 {
        var lastChanged = -1 // either 1 or 2
        for i in 0..&lt;words.count {
            if words[i] == word1 &amp;&amp; lastChanged != 1 {
                index1 = i
                lastChanged = 1
            }
            else if words[i] == word2 &amp;&amp; lastChanged != 2 {
                index2 = i
                lastChanged = 2
            }
            
            if index1 != -1 &amp;&amp; index2 != -1 {
                res = min(res, abs(index1 - index2))
            }
        }
    }
    else {
        for i in 0..&lt;words.count {
            if words[i] == word1 {
                index1 = i
            }
            if words[i] == word2 {
                index2 = i
            }
            if index1 != -1 &amp;&amp; index2 != -1 {
                res = min(res, abs(index1 - index2))
            }
        }
    }
    
    return res
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)

&gt; Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

&gt; **Note**:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

&gt;
</code></pre>
<p><strong>Example 1</strong>:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)</p>
<pre><code>
&gt;
</code></pre>
<p><strong>Example 2</strong>:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest)</p>
<pre><code>
&gt; **Follow Up**:
&gt; Can you do it in O(n) time?

&lt;details&gt;&lt;summary&gt;Use Sum Dictionary&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func maxSubArrayLen(_ nums: [Int], _ k: Int) -&gt; Int {
        var sumToIndex = [Int : Int]()
        sumToIndex[0] = -1 // This is essential
        
        var res = 0
        var sum = 0
        for i in 0..&lt;nums.count {
            sum += nums[i]
            if let pre = sumToIndex[sum - k] {
                res = max(res, i - pre)
            }
            
            // Only update when there's no sum key. Because we want to keep farmost index which has this sum
            if sumToIndex[sum] == nil {
                sumToIndex[sum] = i
            }
        }
        return res
    }
}
</code></pre>
<div class="highlight highlight-source-objc"><pre>+ (<span class="pl-c1">NSInteger</span>)maxSubArrayLen:(<span class="pl-c1">NSArray</span> &lt;<span class="pl-c1">NSNumber</span> *&gt; *)nums withK:(<span class="pl-c1">NSInteger</span>)k
{
	<span class="pl-c1">NSMutableDictionary</span> *sumToIndex = [<span class="pl-c1">NSMutableDictionary</span> <span class="pl-c1">new</span>];
	sumToIndex[@<span class="pl-c1">0</span>] = @(-<span class="pl-c1">1</span>);
	
	<span class="pl-c1">NSInteger</span> sum = <span class="pl-c1">0</span>;
	<span class="pl-c1">NSInteger</span> res = <span class="pl-c1">0</span>;
	<span class="pl-k">for</span> (<span class="pl-c1">NSInteger</span> i = <span class="pl-c1">0</span>; i &lt; nums.<span class="pl-smi">count</span>; i++) {
		sum += [nums[i] <span class="pl-c1">integerValue</span>];
		<span class="pl-c1">NSInteger</span> restSum = sum - k;
		<span class="pl-k">if</span> (sumToIndex[@(restSum)] != <span class="pl-c1">nil</span>) {
			res = <span class="pl-c1">MAX</span>(res, i - [sumToIndex[@(restSum)] <span class="pl-c1">integerValue</span>]);
		}
		
		<span class="pl-k">if</span> (sumToIndex[@(sum)] == <span class="pl-c1">nil</span>) {
			sumToIndex[@(sum)] = @(i);
		}
	}
	<span class="pl-k">return</span> res;
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#product-of-array-except-self" id="user-content-product-of-array-except-self"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/product-of-array-except-self/" rel="nofollow">Product of Array Except Self</a>
</h4>
<blockquote>
<p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
</blockquote>
<blockquote>
<p>Solve it <strong>without division</strong> and in O(n).</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example, given [1,2,3,4], return [24,12,8,6].
</code></pre>
<blockquote>
<p><strong>Follow up</strong>:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
</blockquote>
<details><summary>Use two product dictionary (similar to sum dictionary), one from left to right, another from right to left.</summary><p>
```swift
class Solution {
    func productExceptSelf(_ nums: [Int]) -&gt; [Int] {
        var a = 1
        var results: [Int] = []
        for i in 0..<code>    a = 1
    for i in stride(from: nums.count - 1, to: -1, by: -1) {
        results[i] *= a
        a *= nums[i]
    }
    
    return results
}
</code>
</p>
<p>}</p>
<pre><code>
&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Rotate Array](https://leetcode.com/problems/rotate-array/)

&gt; Rotate an array of n elements to the right by k steps.

&gt; 
</code></pre>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<pre><code>
&gt; **Note**:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

&gt; Hint:

&gt; Could you do it in-place with O(1) extra space?

&gt; Related problem: [Reverse Words in a String II](https://github.com/honghaoz/CrackingTheCodingInterview/wiki/String#reverse-words-in-a-string-ii)

&lt;details&gt;&lt;summary&gt;Use swift array slice&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func rotate(_ nums: inout [Int], _ k: Int) {
        guard nums.isEmpty == false else { return }
		
		let k = k % nums.count
		let rightPart = nums[(nums.count - k)..&lt;nums.count]
		let leftPart = nums[0..&lt;(nums.count - k)]
		nums = Array(rightPart) + Array(leftPart)
    }
}
</code></pre>
</details>
<details><summary>Rotate each segments, then rotate the whole segment</summary><p>
```swift
// Swift
class Solution {
    func rotate(_ nums: inout [Int], _ k: Int) {
        guard nums.isEmpty == false else { return }
</p>
<pre><code>    let k = k % nums.count
    // rotate elements except rest k elements
    rotate(&amp;nums, 0, nums.count - k)
    // rotate rest k elements
    rotate(&amp;nums, nums.count - k, nums.count)
    // rotate whole array
    rotate(&amp;nums, 0, nums.count)
}

func rotate(_ nums: inout [Int], _ from: Int, _ to: Int) {
    guard 0 &lt;= from &amp;&amp; from &lt; to &amp;&amp; to &lt;= nums.count else { return }
    
    var left = from
    var right = to - 1
    while left &lt; right {
        (nums[left], nums[right]) = (nums[right], nums[left])
        left += 1
        right -= 1
    }
}
</code></pre>
<p>}</p>
<pre><code>
```objective-c
// Objective-C
+ (void)rotate:(NSMutableArray &lt;NSNumber *&gt; *)nums k:(NSInteger)k
{
	if (nums.count == 0) {
		return;
	}
	
	NSInteger reducedK = k % nums.count;
	
	[self rotate:nums from:0 to:nums.count - reducedK];
	[self rotate:nums from:nums.count - reducedK to: nums.count];
	[self rotate:nums from:0 to:nums.count];
}

+ (void)rotate:(NSMutableArray &lt;NSNumber *&gt; *)nums from:(NSInteger)from to:(NSInteger)to
{
	if (!(0 &lt;= from &amp;&amp; from &lt; to &amp;&amp; to &lt;= nums.count)) {
		return;
	}
	
	NSInteger times = (to - from) / 2;
	NSInteger left = from;
	NSInteger right = to - 1;
	
	for (NSInteger i = 0; i &lt; times; i++) {
		NSNumber *temp = nums[left];
		nums[left] = nums[right];
		nums[right] = temp;
		
		left += 1;
		right -= 1;
	}
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#rotate-image" id="user-content-rotate-image"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/rotate-image/" rel="nofollow">Rotate Image</a>
</h4>
<blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>
</blockquote>
<blockquote>
<p>Rotate the image by 90 degrees (clockwise).</p>
</blockquote>
<blockquote>
<p>Follow up: Could you do this in-place?</p>
</blockquote>
<details><summary>Rotate level by level, then by item</summary><p>
<img alt="screen shot 2016-12-17 at 4 34 42 pm" src="https://cloud.githubusercontent.com/assets/3926785/21289909/ed38ad2c-c476-11e6-8915-d58d8f1f8822.png" width="214"/>
</p>
<div class="highlight highlight-source-swift"><pre><span class="pl-c"><span class="pl-c">//</span> Swift</span>
<span class="pl-c"></span><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
    <span class="pl-k">func</span> <span class="pl-en">rotate</span>(<span class="pl-en">_</span> <span class="pl-smi">matrix</span>: <span class="pl-k">inout</span> [[<span class="pl-c1">Int</span>]]) {
		<span class="pl-k">let</span> d <span class="pl-k">=</span> matrix.<span class="pl-c1">count</span>
        <span class="pl-k">for</span> level <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..&lt;</span><span class="pl-c1">Int</span>(<span class="pl-c1">ceil</span>(<span class="pl-c1">Double</span>(d <span class="pl-k">/</span> <span class="pl-c1">2</span>))) {
            <span class="pl-k">for</span> j <span class="pl-k">in</span> level<span class="pl-k">..&lt;</span>(d <span class="pl-k">-</span> level <span class="pl-k">-</span> <span class="pl-c1">1</span>) {
                (matrix[level][j], matrix[d <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>][level], matrix[d <span class="pl-k">-</span> level <span class="pl-k">-</span> <span class="pl-c1">1</span>][d <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>], matrix[j][d <span class="pl-k">-</span> level <span class="pl-k">-</span> <span class="pl-c1">1</span>]) <span class="pl-k">=</span>
                    (matrix[d <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>][level], matrix[d <span class="pl-k">-</span> level <span class="pl-k">-</span> <span class="pl-c1">1</span>][d <span class="pl-k">-</span> j <span class="pl-k">-</span> <span class="pl-c1">1</span>], matrix[j][d <span class="pl-k">-</span> level <span class="pl-k">-</span> <span class="pl-c1">1</span>], matrix[level][j])
            }
        }
	}
}</pre></div>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#spiral-matrix" id="user-content-spiral-matrix"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/spiral-matrix/" rel="nofollow">Spiral Matrix</a>
</h4>
<blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given the following matrix:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
You should return [1,2,3,6,9,8,7,4,5].
</code></pre>
<details><summary>Straightforward way, use four directions</summary><p>
```swift
class Solution {
    func spiralOrder(_ matrix: <a class="internal absent" href="/honghaoz/CrackingTheCodingInterview/wiki/Int">Int</a>) -&gt; [Int] {
        var results = [Int]()
</p>
<pre><code>    let m = matrix.count
    guard m &gt; 0 else { return results }
    let n = matrix[0].count
    guard n &gt; 0 else { return results }
    
    var checked: [[Bool]] = Array(repeating: Array(repeating: false, count: n), count: m)
    
    var direction: Int = 1
    var i = 0
    var j = 0
    while true {
        if checked[i][j] == false {
            results.append(matrix[i][j])
            checked[i][j] = true
            
            if results.count == m * n {
                return results
            }
        } else {
            break
        }
        
        switch direction {
            case 1:
                if j + 1 &gt;= n || checked[i][j + 1] == true {
                    direction = 2
                    i += 1
                } else {
                    j += 1
                }
                
            case 2:
                if i + 1 &gt;= m || checked[i + 1][j] == true {
                    direction = 3
                    j -= 1
                } else {
                    i += 1
                }
                
            case 3:
                if j - 1 &lt; 0 || checked[i][j - 1] == true {
                    direction = 4
                    i -= 1
                } else {
                    j -= 1
                }
                
            case 4:
                if i - 1 &lt; 0 || checked[i - 1][j] == true {
                    direction = 1
                    j += 1
                } else {
                    i -= 1
                }
                
            default:
                break;
        }
    }
    
    return results
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)

&gt; Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

&gt;
</code></pre>
<p>For example,
Given n = 3,
You should return the following matrix:
[
[ 1, 2, 3 ],
[ 8, 9, 4 ],
[ 7, 6, 5 ]
]</p>
<pre><code>
&lt;details&gt;&lt;summary&gt;From outer level to inner level, update matrix&lt;/summary&gt;&lt;p&gt;

```swift
class Solution {
    func generateMatrix(_ n: Int) -&gt; [[Int]] {
        var results: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: n)
        guard n &gt; 0 else { return results }
        
        var index = 1
        
        var loop = 0
        for loop in 0..&lt;Int(ceil(Double(n) / 2)) {
            var i = loop
            var j = loop
            for j in (0 + loop)..&lt;(n - loop) {
                results[i][j] = index
                index += 1
            }
            
            j = n - 1 - loop
            for i in (1 + loop)..&lt;(n - loop) {
                results[i][j] = index
                index += 1
            }
            
            i = n - 1 - loop
            for j in stride(from: n - 2 - loop, to: loop - 1, by: -1) {
                results[i][j] = index
                index += 1
            }
            
            j = loop
            for i in stride(from: n - 2 - loop, to: loop, by: -1) {
                results[i][j] = index
                index += 1
            }
        }
        
        return results
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#valid-sudoku" id="user-content-valid-sudoku"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/valid-sudoku/" rel="nofollow">Valid Sudoku</a>
</h4>
<blockquote>
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" rel="nofollow">Sudoku Puzzles - The Rules</a>.</p>
</blockquote>
<blockquote>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character '.'.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
</blockquote>
<details><summary>Straightforward way, check row/column/block</summary><p>
```swift
class Solution {
    func isValidSudoku(_ board: <a class="internal absent" href="/honghaoz/CrackingTheCodingInterview/wiki/Character">Character</a>) -&gt; Bool {
        return checkRow(board) &amp;&amp; checkColumn(board) &amp;&amp; checkBlock(board)
    }
</p>
<pre><code>private func checkRow(_ board: [[Character]]) -&gt; Bool {
    for row in board {
        if haveDuplicates(row.flatMap({ Int(String($0)) })) {
            return false
        }
    }
    
    return true
}

private func checkColumn(_ board: [[Character]]) -&gt; Bool {
    for j in 0..&lt;9 {
        var col: [Int] = []
        for i in 0..&lt;9 {
            if let num = Int(String(board[i][j])) {
                col.append(num)
            }
        }
        if haveDuplicates(col) {
            return false
        }
    }
    return true
}

private func checkBlock(_ board: [[Character]]) -&gt; Bool {
    // for each big block
    for i in 0..&lt;3 {
        for j in 0..&lt;3 {
            var nums = [Int]()
            for x in (i * 3)..&lt;(i * 3 + 3) {
                for y in (j * 3)..&lt;(j * 3 + 3) {
                    if let num = Int(String(board[x][y])) {
                        nums.append(num)
                    }
                }
            }
            if haveDuplicates(nums) {
                return false
            }
        }
    }
    return true
}

private func haveDuplicates(_ nums: [Int]) -&gt; Bool {
    guard nums.count &gt; 0 else { return false }
    var check = Set&lt;Int&gt;()
    for num in nums {
        let (inserted, _) = check.insert(num)
        if inserted == false {
            return true
        }
    }
    
    return false
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)

&gt; Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

&gt; click to show follow up.

&gt; Follow up:
- Did you use extra space?
- A straight forward solution using O(mn) space is probably a bad idea.
- A simple improvement uses O(m + n) space, but still not the best solution.
- Could you devise a constant space solution?

&lt;details&gt;&lt;summary&gt;Use first row and first col to record zeroes, also need to check whether the first row/col already has zero&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func setZeroes(_ matrix: inout [[Int]]) {
        guard matrix.count &gt; 0 else { return }
        let m = matrix.count
        guard matrix[0].count &gt; 0 else { return }
        let n = matrix[0].count
        
        var row0HasZero = false
        var col0HasZero = false
        
        // check row0
        for j in 0..&lt;n {
            if matrix[0][j] == 0 {
                row0HasZero = true
                break
            }
        }
        
        // check col0
        for i in 0..&lt;m {
            if matrix[i][0] == 0 {
                col0HasZero = true
                break
            }
        }
        
        // check rest, update row0 and col0
        for i in 0..&lt;m {
            for j in 0..&lt;n {
                if i == 0 || j == 0 {
                    continue
                }
                
                if matrix[i][j] == 0 {
                    matrix[i][0] = 0
                    matrix[0][j] = 0
                }
            }
        }
        
        // update with row0
        for j in 1..&lt;n {
            if matrix[0][j] == 0 {
                // update the col
                for i in 0..&lt;m {
                    matrix[i][j] = 0
                }
            }
        }
        
        // update with col0
        for i in 1..&lt;m {
            if matrix[i][0] == 0 {
                // update the row
                for j in 0..&lt;n {
                    matrix[i][j] = 0
                }
            }
        }
        
        // update row0 if row0 has zero
        if row0HasZero {
            for j in 0..&lt;n {
                matrix[0][j] = 0
            }
        }
        
        // update col0 if col0 has zero
        if col0HasZero {
            for i in 0..&lt;m {
                matrix[i][0] = 0
            }
        }
    }
}

</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#next-permutation" id="user-content-next-permutation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/next-permutation/" rel="nofollow">Next Permutation</a>
</h4>
<blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
</blockquote>
<blockquote>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p>
</blockquote>
<blockquote>
<p>The replacement must be in-place, do not allocate extra memory.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>Here are some examples. 
Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre>
<details><summary>A solution needs to be memorized</summary><p>
```swift
class Solution {
    func nextPermutation(_ nums: inout [Int]) {
        var k = -1 // the index that nums[k] &lt; nums[k + 1]
        for i in stride(from: nums.count - 2, to: -1, by: -1) {
            if nums[i] &lt; nums[i + 1] {
                k = i
                break
            }
        }
</p>
<pre><code>    // Descending order, just reverse it
    if k == -1 {
        nums.reverse()
        return
    }
    
    var l = -1 // the largest index that nums[l] &gt; nums[k]
    for i in stride(from: nums.count - 1, to: k, by: -1) {
        if nums[i] &gt; nums[k] {
            l = i
            break
        }
    }
    
    // Swap k and l
    (nums[k], nums[l]) = (nums[l], nums[k])
    // reverse from k + 1 to end
    reverse(&amp;nums, k + 1, nums.count)
}

func reverse(_ nums: inout [Int], _ from: Int, _ to: Int) {
    var left = from
    var right = to - 1
    while left &lt; right {
        (nums[left], nums[right]) = (nums[right], nums[left])
        left += 1
        right -= 1
    }
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Gas Station](https://leetcode.com/problems/gas-station/)

&gt; There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

&gt; You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

&gt; Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

&gt; **Note**:
The solution is guaranteed to be unique.

&lt;details&gt;&lt;summary&gt;A solution needs to be memorized&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    func canCompleteCircuit(_ gas: [Int], _ cost: [Int]) -&gt; Int {
        let count = gas.count
        if count == 0 {
            return -1
        }
        
        var start = count - 1
        var end = 0
        var sum = gas[start] - cost[start]
        while start &gt; end {
            if sum &gt;= 0 {
                sum += gas[end] - cost[end]
                end += 1
            }
            else {
                start -= 1
                sum += gas[start] - cost[start]
            }
        }
        
        return sum &gt;= 0 ? start : -1
    }
}
</code></pre>
</details>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#sliding-window-maximum" id="user-content-sliding-window-maximum"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a><a href="https://leetcode.com/problems/sliding-window-maximum/" rel="nofollow">Sliding Window Maximum</a>
</h4>
<blockquote>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
</blockquote>
<blockquote>
</blockquote>
<pre><code>For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.
</code></pre>
<blockquote>
</blockquote>
<pre><code>Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
Therefore, return the max sliding window as [3,3,5,5,6,7].
</code></pre>
<blockquote>
<p><strong>Note</strong>:
You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.</p>
</blockquote>
<blockquote>
<p><strong>Follow up</strong>:
Could you solve it in linear time?</p>
</blockquote>
<blockquote>
<p><strong>Hint</strong>:</p>
</blockquote>
<ul>
<li>How about using a data structure such as deque (double-ended queue)?</li>
<li>The queue size need not be the same as the window’s size.</li>
<li>Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ul>
<details><summary>A solution needs to be memorized</summary><p>
```swift
class Solution {
    func maxSlidingWindow(_ nums: [Int], _ k: Int) -&gt; [Int] {
        var res: [Int] = []
		var q: [Int] = [] // indices
</p>
<pre><code>	for i in 0..&lt;nums.count {
		// Check whether the first element is still in the window, if not, remove it
		if let first = q.first, first &lt; i - k + 1 { // i - k + 1 is the first index of window
			q.removeFirst()
		}
		
		// Check the coming element, clear smaller elements
		while q.isEmpty == false &amp;&amp; nums[q.last!] &lt; nums[i] {
			q.removeLast()
		}
		
		q.append(i)
		
		// Record if needed, if has more than k elements
		if (i - k + 1 &gt;= 0) {
			res.append(nums[q.first!])
		}
	}
	
	return res
}
</code></pre>
<p>}</p>
<pre><code>&lt;/p&gt;&lt;/details&gt;

*****************************************************************************************************************
#### [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)

&gt; Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

&gt;
</code></pre>
<p>For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<pre><code>
&gt; Your algorithm should run in O(n) complexity.

&lt;details&gt;&lt;summary&gt;For each num, expand to left and to right. Use a hash to help&lt;/summary&gt;&lt;p&gt;
```swift
class Solution {
    // Basic idea is use a hash to record whether the num is checked
    // Then for each num, expand to right and expand to left, stops when it's checked or not in the dictionary
    func longestConsecutive(_ nums: [Int]) -&gt; Int {
        // Use a hash to store whether this num has been checked
        var checked: [Int : Bool] = [:] 
        for i in 0..&lt;nums.count {
            checked[nums[i]] = false
        }
        
        var res = 1
        for i in 0..&lt;nums.count {
            // If current num has been checked, skip
            if checked[nums[i]] == true {
                continue
            }
            
            // Include current num, the length is 1
            var length = 1
            
            // Expand to right
            var right = nums[i] + 1
            while checked[right] == false { // nil or true won't continue
                length += 1
                checked[right] = true
                right += 1
            }
            
            // Expand to left
            var left = nums[i] - 1
            while checked[left] == false { // nil or true won't continue
                length += 1
                checked[left] = true
                left -= 1
            }
            
            res = max(res, length)
        }
        
        return res
    }
}
</code></pre>
</details>

        </div>

        <div class="wiki-footer gollum-markdown-content boxed-group" id="wiki-footer">
          <div class="boxed-group-inner wiki-auxiliary-content markdown-body">
            <p>我是有底线的</p>

          </div>
        </div>
    </div>]