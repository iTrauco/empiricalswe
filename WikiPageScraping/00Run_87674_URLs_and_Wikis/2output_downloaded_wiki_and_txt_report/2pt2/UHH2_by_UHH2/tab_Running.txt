[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h1>
<a aria-hidden="true" class="anchor" href="#running" id="user-content-running"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Running</h1>
<p>After installing and compiling, you can run the first example. In general, there are two possibilities of how to run your code: within SFrame or within CMSSW. The central class to provide in both cases is an implementation of the abstract class <code>AnalysisModule</code>, which will be constructed for each dataset and whose <code>process</code> method will be called for each event.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#running-with-sframe" id="user-content-running-with-sframe"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Running with SFrame</h2>
<p>Running with SFrame is only possible on the ntuple format. As output, a new ntuple can be created (possibly with some new, user-defined branches in the output). Running is done via SFrame, so all instructions relevant for SFrame in general also applies here. In particular, to run SFrame, a xml configuration file should be provided, which specifies input data and some options. For example, running one of the examples locally, change to <code>UHH2/examples</code> and execute:</p>
<pre><code>sframe_main config/Example.xml
</code></pre>
<p>This will construct the <code>ExampleModule</code> class (which is an implementation of the abstract <code>AnalysisModule</code>) and execute its <code>process</code> method each time.</p>
<p>For available options, see the comments in <code>UHH2/examples/config/Example.xml</code>. In particular, the options in the <code>UserConfig</code> section in the xml file control which branches are read and which <code>AnalysisModule</code> is run. Besides these <code>UHH2</code>-specific options, the xml files are usual SFrame xml configurations, so in particular for specifying the input dataset, running mode (local vs. proof), logging and other things, refer to the SFrame documentation. Some comments for frequently used options exist in <code>Example.xml</code>.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#miscellaneous-notes-for-running-sframe" id="user-content-miscellaneous-notes-for-running-sframe"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Miscellaneous notes for running SFrame</h3>
<ul>
<li>In the xml file, the only <code>Library</code> and <code>Package</code> to declare is the one which contains your <code>AnalysisModule</code>. This is because in <code>UHH2</code> (in contrast to <code>UHHAnalysis</code>), the library dependencies are explicitly given when building already</li>
<li>
<code>par</code> file created for running with proof is a dummy file which does not compile anything, so this will work only when running on a cluster with a shared filesystem and the <code>UHH2</code> binaries are located on that shared filesystem.</li>
</ul>
<h2>
<a aria-hidden="true" class="anchor" href="#running-with-cmssw" id="user-content-running-with-cmssw"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Running with CMSSW</h2>
<p>Running with CMSSW requires miniAOD (or, with some changes, AOD) as input. As output, either CMSSW output (=miniAOD, possibly with some more data), the ntuple format, or a combination of both is possible. Note that the <code>AnalysisModule</code> cannot create output to be saved in the CMSSW data format; this is only possible for the ntuple format.</p>
<p>To run a module within CMSSW, use <code>UHH2/core/python/ntuplewriter_only.py</code> as template and change the settings in the <code>AnalysisModule</code> section to load the right library and <code>AnalysisModule</code> class. Then, run <code>cmsRun</code> on the configuration file. The <code>NtupleWriter</code> CMSSW plugin will convert the miniAOD format on the fly and call the constructor and <code>process</code> method of the specified <code>AnalysisModule</code>.</p>

        </div>

    </div>]