[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h1>
<a aria-hidden="true" class="anchor" href="#event-class" id="user-content-event-class"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Event Class</h1>
<p>The <code>Event</code> class is a central class in this framework and provides access to (read and modify) the event content; it is passed to the <code>process</code> method of an <code>AnalysisModule</code>. This page explains how the <code>Event</code> class can be used.</p>
<p>Broadly, there are two ways how data is stored in the <code>Event</code> container: as direct data members for accessing common data and via the mechanisms provided by <code>GenericEvent</code>, the base class of <code>Event</code> (triggers are a somewhat special case which is considered a part of the "direct data members" here). The main reason for having two different mechanisms is because it allows combining the simplicity of a "simple struct" approach of the <code>Event</code> container with the power of the <code>GenericEvent</code> which allows to store data of arbitrary types. It is expected that many analyses do not need <code>GenericEvent</code> at all and it is enough to use the members of <code>Event</code>.</p>
<p>With this parallel structure of <code>Event</code>, however, it is good to know the rules and conventions which governs the access and how to use the <code>Event</code> class efficiently.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#direct-data-access" id="user-content-direct-data-access"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Direct Data Access</h2>
<p>The first way of accessing event data is via the data members a defined in <code>UHH2/core/include/Event.h</code>. This comprises basic event information such as runid, eventid, but also jets, electrons, muons, etc. The <code>AnalysisModule</code> can read and also modify the event content using the data members. However, there is one <strong>important rule</strong>: never change the data members <strong>pointers</strong>, only change the content pointed-to. This means code like this is forbidden:</p>
<pre><code>event.jets = new vector&lt;Jet&gt;();
</code></pre>
<p>The reason is that this will break synchronization assumptions with <code>GenericEvent</code>, which are explained in the next section. Instead of the above, change the thing pointed-to instead:</p>
<pre><code>*event.jets = vector&lt;Jet&gt;();
</code></pre>
<h3>
<a aria-hidden="true" class="anchor" href="#trigger-access" id="user-content-trigger-access"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Trigger Access</h3>
<p>A special case is accessing trigger information: As the set of triggers can change from run to run, a mapping between trigger names (string "HLT_...") and trigger indices, i.e. the index into the vector of booleans which is stored for each event, has to be handled efficiently. This is done in the <code>Event</code> class by providing the <code>get_trigger_index</code>, <code>passes_trigger</code> and <code>lookup_trigger</code> methods in the <code>Event</code> class; see the documentation in the header file for usage instructions.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#access-via-genericevent" id="user-content-access-via-genericevent"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Access via GenericEvent</h2>
<p>The <code>GenericEvent</code> is the class which implements saving arbitrary data; as <code>GenericEvent</code> is the base class of <code>Event</code>, all of the below applying to <code>GenericEvent</code> also applies to <code>Event</code>.</p>
<p>Saving a new data member in the <code>GenericEvent</code> is a two-step process: first, the member has to be <em>declared</em> via the <code>GenericEventStructure</code>; this is usually not called cirectly, but happens behind the scenes when using <code>Context::get_handle&lt;T&gt;</code>. The result of this operation is a <code>GenericEvent::Handle&lt;T&gt;</code>. With this <code>Handle</code>, one can get or set the value of the <code>GenericEvent</code> via <code>GenericEvent::get</code> and <code>GenericEvent::set</code>; see documentation in the header.</p>
<p>An example making use of this mechanism is provided in <code>examples/src/ExampleModuleComposing.cxx</code>: The <code>CalcHT1</code> method calculates HT and stores it in the <code>Event</code> using the mechanism described above, and <code>PrintHT1</code> reads that value. See comments in the <code>cxx</code> file for more information.</p>
<p>As a rule, <code>GenericEventStructure</code> is only accessible at time of setup, i.e. during construction of <code>AnalysisModule</code>. At this time, all event members have to be declared. Once the <code>Event</code> is created (e.g. during <code>process</code>), it is not possible to add new members.</p>
<p>Reading event data through a <code>Handle</code> assumes that the data is present. In general, there are two possible sources of data: another <code>AnalysisModule</code> called <code>GenericEvent::set</code> with a compatible <code>Handle</code> (=same name, same type), or the data is present in the input root file. For the former case, things work like you expect: both <code>AnalysisModule</code>s must construct a <code>Handle</code> with exactly the same name and type, which then refers to the same object stored in the <code>GenericEvent</code> container. As long as <code>GenericEvent::set</code> is called before <code>GenericEvent::get</code>, everything will work as expected and the value retrieved by <code>get</code> is the one set by <code>set</code>. (Note that trying to <code>get</code> a value before <code>set</code> will result in an exception).</p>
<p>If, however, you want to read the data from the input root file, you have to tell the framework to do so. There are two methods: a low-level method for full control is to call</p>
<pre><code>ctx.declare_event_input&lt;T&gt;("branchname");
</code></pre>
<p>which tells the framework that it should try to read a branch called "branchname" of type <code>T</code> from the input root file. The second method is to specify in the sframe <code>xml</code> file a special setting called "additionalBranches":</p>
<pre><code>&lt;Item Name="additionalBranches" Value="branchname1 branchname2 branchname3" /&gt;
</code></pre>
<p>This tells the framework to read in -- and actually also write to the oputput, in case output is written at all -- the branches of the specified names. In either case, the event data is acessible via an according <code>Handle&lt;T&gt;</code> using the right name and type. In general, the second method is more compact and needs less code and thus is the preferred method. However, in some circumstances, you might need more control over some details, in which case you can use the first method. For example, when specifying additional branches via the xml file, they will be written to the output by default; this is <em>not</em> the case when calling <code>declare_event_input</code> (use in addition <code>declare_event_output</code> for writing output). Additionally, <code>declare_event_input</code> allows to specify a branchname which is different from the handle name; for the "additionalBranches" method, on the other hand, the branchname and <code>Handle</code> name are always the same.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#implementation" id="user-content-implementation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Implementation</h3>
<p>Internally, the framework mostly deals with methods from <code>GenericEvent</code>, and then synchronizes with <code>Event</code> only when needed. In particular, this means that <em>all</em> event input to be read from the input file and <em>all</em> event output to be written to the output file are saved as data members in the <code>GenericEvent</code>. This also means that the very same data can be accessed in multiple ways. For example, jets can be accessed both via <code>Event::jets</code>, but also via the <code>GenericEvent</code> methods using a <code>Handle</code> constructed with the name "jets". The convention is that the name of the <code>Handle</code> is the same as the member name in the <code>Event</code> class.</p>
<p>The two ways of accessing data have to be synchronized. This is achieved by:</p>
<ul>
<li>after reading an event from disk (into <code>GenericEvent</code>), the data is copied into <code>Event</code> as required. This is only required for plain data, as the pointers of <code>Event</code> point to the data members of <code>GenericEvent</code>. This coupling of the <code>Event</code> pointers to the <code>GenericEvent</code> content is the reason for the rule never to change the pointers directly, as this would break the coupling.</li>
<li>just before writing to disk (from <code>GenericEvent</code>), the <code>GenericEvent</code> content is set to the content of <code>Event</code>. This only affects plain data, as the pointers always point to the <code>GenericEvent</code> anyway.</li>
</ul>
<p>This synchronization is implemented in the <code>EventHelper</code> class.</p>

        </div>

    </div>]