[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <h2>
<a aria-hidden="true" class="anchor" href="#what-is-this" id="user-content-what-is-this"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>What is this?</h2>
<p>This is my attempt to create a basic IRC client written in Haskell. DIRC stands for Duke's IRC.</p>
<p>An IRC client is a great project to learn many parts of a language and platform. The areas covered will be a UI, networking and concurrency. The UI chosen for this project is GTK3 using the gtk3 wrappers for Haskell. The project is built and deployed using Cabal. The project will be structured using modules. This provides a fantastic grand tour of basic Haskell application development, from start to finish.</p>
<p>IRC is very useful for this purpose because the protocol is very simple. It is a text-based protcol with a simple command structure. Only one socket connection is required. The server sends commands, which are read from the socket. The client sends commands in the same form, which are written to the same socket.</p>
<p><a href="https://tools.ietf.org/html/rfc2812" rel="nofollow">RFC 2812</a> describes the protocol. However, IRC has evolved organically over the decades and so the RFC really only describes how most IRC servers <em>should</em> behave. But, the RFC is a good starting point.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#basic-design-ideas" id="user-content-basic-design-ideas"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Basic Design Ideas</h2>
<h3>
<a aria-hidden="true" class="anchor" href="#networking" id="user-content-networking"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Networking</h3>
<p>I am planning on designing IRC server communication with the <a href="http://en.wikipedia.org/wiki/Actor_model" rel="nofollow">Actor model</a>. Each IRC server and each IRC channel will be modeled as actors, sending
and receiving high-level messages, to model the user experience of chatting on IRC.</p>
<p>I intend to roll my own Actor model even though there are Actor libraries available on hackage. This is an education experience, and I want to learn the nuts and bolts of the concurrency in Haskell. The building blocks I am looking at are <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:forkIO" rel="nofollow">forkIO</a> to "spark" off a computation into a separate thread and <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent-Chan.html" rel="nofollow">channels</a> to manage communication between threads.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#ui" id="user-content-ui"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>UI</h3>
<p>I am planning on using GTK, mostly because I am more familiar with it. I considered hsQML, the Haskell bindings over the Qt Quick toolkit, but I figure this project will be hard enough to do in Haskell, so sticking to familiar territory to ensure that I can finish the entire project without getting stuck in the weeds learning an new UI toolkit as well.</p>
<p>The UI will be developed as a Functional Reactive UI built using the Reactive Banana framework. The behavior
of the UI will be abstracted from the implementation through events and behaviors. Once I get this working in GTK, it might be fun to write implementations for other toolkits (like hsQML) or for even more fun, creating a web interface using Yesod and WebSockets. Some interesting directions for future work!</p>

        </div>

    </div>]