[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p>This project is a modular implementation of timely dataflow in Rust.</p>
<p>Why not start with <a href="https://github.com/frankmcsherry/timely-dataflow/wiki/An-introduction">an introduction to writing timely dataflow programs</a>?</p>
<p>This document contains explanations both of how timely dataflow (the concept) works, and how to use timely dataflow in Rust (the software). In the fullness of time, the project will get a better name, and the two will stop being conflated.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#motivation" id="user-content-motivation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Motivation</h1>
<p>Timely dataflow is a framework for data-parallel programming, with the goal of letting you write quite general programs that will scale to large numbers of independent workers (<em>i.e.</em> multiple threads, processes, and computers).</p>
<p>The main distinction between timely dataflow and other dataflow systems before it lies in its generality. Most dataflow systems constrain your dataflow to a directed acyclic graph, which makes control structures like loops difficult to write. This makes some sense, because dataflow is largely about excising control structures that are not part of the data themselves. Nonetheless, there are reasonable ways to write cyclic dataflow computations, and timely dataflow is about helping you do this without losing your sanity.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#core-ideas" id="user-content-core-ideas"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Core ideas</h1>
<p>Timely dataflow is a dataflow programming model, which means that at its lowest level it views computations as a directed graph whose vertices are <em>operators</em>, and whose edges indicate <em>channels</em> along which data may move from one operator to another. Each batch of data bear a logical <em>timestamp</em>, which encodes some minimal control information (for example, the loop iteration in which the data were produced).</p>
<p>In a perfect world, you wouldn't have to understand or reason about this dataflow representation; we have found several other programming idioms reduce nicely to dataflow, with the most common one being the collection or stream oriented programming you see in languages like SQL, LINQ, and Datalog. Timely dataflow is intentionally designed to let you program at different levels: you can write raw dataflow if you like, or built-in operators that resemble SQL operators, or mix and match as you like. You can even write your own custom operators <em>in situ</em>.</p>
<p>One goal of timely dataflow is to still let you write programs with common imperative programming idioms. Where possible, we would like to let you write something like a <code>while</code> loop, with a minimal set of restrictions to make the implementation possible in dataflow. And you should be able to wrap that <code>while</code> loop in another <code>while</code> loop, because that can be useful.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#tracking-progress" id="user-content-tracking-progress"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Tracking progress</h1>
<p>The most technically interesting and challenging part of timely dataflow is identifying graph structures that effect more traditional control structures from imperative programming. How do we implement a <code>for</code> loop in dataflow; just with a cycle? It is more complicated than that, because someone somewhere needs to notice when we "go around" the loop.</p>
<p>A good deal of the work in timely dataflow is tracking and reporting the "progress" of the computation. As data circulate around loops and other graph structures, operators may need to know that the computation has logically proceeded to the next iteration. This happens partly by annotating data with its associated iteration, but also by clearly notifying operators when all data for some iteration has been received (even if no data was received).</p>
<p>Of course, this is more complicated than just running around a cycle. The graph structures may have nested cycles and other control flow constructs represented as graphs. We'll need to be more general.</p>
<p>More details can be found on the page on <a href="https://github.com/frankmcsherry/timely-dataflow/wiki/Progress-tracking">tracking progress</a>.</p>

        </div>

    </div>]