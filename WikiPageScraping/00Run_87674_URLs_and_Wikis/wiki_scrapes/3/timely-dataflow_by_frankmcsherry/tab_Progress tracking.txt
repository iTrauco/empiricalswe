[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p>The main feature timely dataflow provides, in addition to moving data along dataflow edges, is the indication of progress through the stream of data.</p>
<p>The system alerts each recipient of timestamped data once it can determine that some previously active timestamp will never be seen again. This allows the operator to react with final messages and actions, for example sending aggregates, flushing state, or releasing held resources. The same mechanisms also alert the user as output data emerge from the dataflow graph.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#the-language-of-progress" id="user-content-the-language-of-progress"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The language of progress</h1>
<p>We first need to develop timely dataflow's progress vocabulary.</p>
<p>A timely dataflow graph consists of <strong>operators</strong>, whose <strong>inputs</strong> and <strong>outputs</strong> are connected by <strong>channels</strong>. Each operator input has one associated channel, but an operator output may have many channels leading from it: multiple other operators may want to see the data it produces. Each group of records transmitted in timely dataflow have an associated <strong>timestamp</strong>.</p>
<p>Timely dataflow is responsible for producing information that would let each operator answer the question</p>
<blockquote>
<p>Will I ever see data with this specific timestamp on this specific input of mine?</p>
</blockquote>
<p>To provide this information, timely dataflow imposes some constraints on the structure of the dataflow graph and the behavior of operators.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#constraints" id="user-content-constraints"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Constraints</h1>
<p>The high-level constraint that timely dataflow imposes is that that there should be no cycles in the timely dataflow graph which permit data on some channel to eventually produce data on that channel with the same timestamp. This will let the system reason that once some timestamp has gone away, it will not be seen again.</p>
<p>This property can be difficult to reason about directly, so instead we will impose simpler, local constraints on the graph structure and operator behavior, and argue that these constraints imply the desired global property.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#graph-structure" id="user-content-graph-structure"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Graph structure</h2>
<blockquote>
<p>With one exception, operators may only be constructed from the full set of channels connected to their inputs, and their outputs are not available until this happens.</p>
</blockquote>
<p>This constraint by itself would ensure that dataflow graphs are acyclic, as we could totally order the operators by their construction time, and edges would not be able to go backwards along this order.</p>
<p>Acyclic dataflow graphs are a limitation we hope to avoid. To create cycles, timely dataflow permits one specific system-provided operator to be constructed before the channel connecting its input is available. This is the <code>feedback</code> operator, and it ensures that timestamps are <em>strictly</em> advanced for all data passing through.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#operator-behavior" id="user-content-operator-behavior"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Operator behavior</h2>
<blockquote>
<p>Each operator must respond to input messages only with output messages whose timestamps are at least as large.</p>
</blockquote>
<p>To maintain the strict advancement the <code>feedback</code> operator introduces, each other operator must never "roll back" timestamps. This property is a bit subtle, in that more complicated operators may have multiple inputs and outputs, not all of which should be thought of as directly connected.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#interfaces" id="user-content-interfaces"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Interfaces</h1>
<p>Each operator must implement the <code>Operate&lt;T&gt;</code> trait, parameterized by the timestamp <code>T</code> their inputs and outputs use for data. This trait describes all of the information the system needs to know about the operator in order to reason about progress around the operator.</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-c">// implementors can be treated as operators</span>
<span class="pl-k">pub</span> <span class="pl-k">trait</span> <span class="pl-en">Operate</span>&lt;T: Timestamp&gt; {

    <span class="pl-c">// preliminary information.</span>
    <span class="pl-k">fn</span> <span class="pl-en">inputs</span>(<span class="pl-k">&amp;</span><span class="pl-c1">self</span>) -&gt; <span class="pl-k">u64</span>;
    <span class="pl-k">fn</span> <span class="pl-en">outputs</span>(<span class="pl-k">&amp;</span><span class="pl-c1">self</span>) -&gt; <span class="pl-k">u64</span>;

    <span class="pl-c">// initialization methods, describing internal/external structure and capabilities.</span>
    <span class="pl-k">fn</span> <span class="pl-en">get_internal_summary</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>) -&gt; (<span class="pl-k">Vec</span>&lt;<span class="pl-k">Vec</span>&lt;Antichain&lt;T::Summary&gt;&gt;&gt;, <span class="pl-k">Vec</span>&lt;CountMap&lt;T&gt;&gt;);
    <span class="pl-k">fn</span> <span class="pl-en">set_external_summary</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, <span class="pl-k">Vec</span>&lt;<span class="pl-k">Vec</span>&lt;Antichain&lt;T::Summary&gt;&gt;&gt;, <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;]);

    <span class="pl-c">// run-time methods, indicating changes in capabilities.</span>
    <span class="pl-k">fn</span> <span class="pl-en">push_external_progress</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;])
    fn pull_internal_progress(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;], <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;], <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;]) -&gt; <span class="pl-k">bool</span>;
}</pre></div>
<p>Let's go through each of the groups of methods, and explain what they are about (and what <code>Antichain</code> and <code>CountMap</code> are).</p>
<h2>
<a aria-hidden="true" class="anchor" href="#structure" id="user-content-structure"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Structure</h2>
<p>The first information an operator must declare is what type it plans to use for its timestamp. There are constraints on these types, but the most important one for our purposes is that each timestamp must implement <code>PartialOrd</code>: there must be a way to indicate that some elements are "greater than" others.</p>
<p>An operator must also declare its number of inputs and outputs, clearly. The rest of the methods will operate in terms of numbered inputs and outputs, rather than pointers to things.</p>
<div class="highlight highlight-source-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">trait</span> <span class="pl-en">Operate</span>&lt;T: Timestamp&gt; {

    <span class="pl-c">// preliminary information.</span>
    <span class="pl-k">fn</span> <span class="pl-en">inputs</span>(<span class="pl-k">&amp;</span><span class="pl-c1">self</span>) -&gt; <span class="pl-k">u64</span>;
    <span class="pl-k">fn</span> <span class="pl-en">outputs</span>(<span class="pl-k">&amp;</span><span class="pl-c1">self</span>) -&gt; <span class="pl-k">u64</span>;</pre></div>
<p>There are presently no constraints on the number of inputs and outputs. Some operators have no inputs, some no outputs, some have unboundedly many inputs and some unboundedly many outputs.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#initialization" id="user-content-initialization"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Initialization</h2>
<p>This is where we start to get in to the heavy stuff.</p>
<p>Before a timely dataflow computation starts, the system needs to understand how timestamped data presented to the input of an operator might emerge from an output. For example, it may be that data presented at one input could emerge at two of the operator's outputs, but data presented at another input could emerge only at one specific output, and in that case only with the timestamp advanced.</p>
<p>It may be less obvious, but the system should also communicate the same information about the outside world to the operator: how might data the operator produces on an output eventually return to its inputs?</p>
<p>Let's look at these two methods and talk through their implications</p>
<h3>
<a aria-hidden="true" class="anchor" href="#internal-summarization" id="user-content-internal-summarization"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Internal summarization</h3>
<p>The first method asks the operator to summarize the connectivity of its inputs to its outputs, and to indicate any initial message sending capabilities it intends for each of its outputs.</p>
<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">fn</span> <span class="pl-en">get_internal_summary</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>) -&gt; 
        (<span class="pl-k">Vec</span>&lt;<span class="pl-k">Vec</span>&lt;Antichain&lt;T::Summary&gt;&gt;&gt;, 
         <span class="pl-k">Vec</span>&lt;CountMap&lt;T&gt;&gt;);</pre></div>
<p>The return type is a pair, where the first element should be thought of as a map from <code>(input, output)</code> to a collection of <code>T::Summary</code> objects. A <code>T::Summary</code> is a summary of how <code>T</code> advances. In the simplest case it could just be the identity, saying a timestamp emerges at the output unchanged. More generally, some part of the timestamp might advance, and the operator can indicate that.</p>
<p>The <code>Antichain</code> aspect is a detail of the <code>PartialOrd</code>-eredness of the timestamps and their summaries: there may be several incomparable ways in which the timestamp advances (for example, at least one of two coordinates might advance, but perhaps no guarantee that both would).</p>
<p>The second output should be thought of as a map from <code>(output, timestamp)</code> to an initial count. The count is typically one (a zero is implied for absent keys), and simply indicates that the operator retains the right to emit data with the specified timestamp on the specified output.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#external-summarization" id="user-content-external-summarization"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>External summarization</h3>
<p>The second method is essentially the dual of the first, with the system telling the operator about the connectivity summaries between its outputs and its inputs, and any initial message sending capabilities on each of its inputs.</p>
<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">fn</span> <span class="pl-en">set_external_summary</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, 
        <span class="pl-k">Vec</span>&lt;<span class="pl-k">Vec</span>&lt;Antichain&lt;T::Summary&gt;&gt;&gt;, 
        <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;]);</pre></div>
<p>Only once the system has full information about the operators it manages and the edges between them can it correctly invoke this message. The typical pattern is to call <code>get_internal_summary</code> for each managed operator, think for a bit, and then call <code>set_external_summary</code> for each of them.</p>
<p>The types might be a bit surprising. The second parameter is an owned <code>Vec</code>, and the operator is expected to take this summary for its own use. The third paramter is a reference to a slice of <code>CountMap</code>s, and the operator is expected to drain each (but does not get to own them). The reasoning is that in the latter case, the system will want to repeatedly notify the operator of changes in capabilities, and it would rather re-use the same <code>CountMap</code>s rather than repeatedly allocate and move them to the operator.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#execution" id="user-content-execution"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Execution</h2>
<p>Once a timely dataflow computation starts running, messages will be delivered and consumed, and ideally operators will start release their message sending capabilities, or at least advance the capabilities to later timestamps.</p>
<p>To communicate this information, we again have two methods, corresponding to the system telling the operator about changes in the outside world, and the system requesting information from the operator about internal changes as they are reflected in the outside world.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#external-progress" id="user-content-external-progress"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>External progress</h3>
<p>If for any reason there is a change to times of data an operator might expect on any of its inputs, the system indicates them by simply announcing the changed counts for each input.</p>
<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">fn</span> <span class="pl-en">push_external_progress</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, 
        <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;])</pre></div>
<p>This communication is one-directional: the operator does not reply with any information, and is not obliged to react in any way to this information.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#internal-progress" id="user-content-internal-progress"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Internal progress</h3>
<p>The system also periodically ask each operator about progress it may have made. The system is not obliged to call this method, but if it looks like some operator is holding up the show, it might be a good idea to check in and see if it has gotten anywhere.</p>
<div class="highlight highlight-source-rust"><pre>    <span class="pl-k">fn</span> <span class="pl-en">pull_internal_progress</span>(<span class="pl-k">&amp;</span><span class="pl-k">mut</span> <span class="pl-c1">self</span>, 
        <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;], 
        <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;], 
        <span class="pl-k">&amp;</span><span class="pl-k">mut</span> [CountMap&lt;T&gt;]) -&gt; <span class="pl-k">bool</span>;</pre></div>
<p>There are three additional arguments to this method, and a boolean return value. The three arguments are:</p>
<pre><code>1. changes to the capabilities on each output.
2. amount of data consumed on each input.
3. amount of data produced on each output. 
</code></pre>
<p>The first argument probably makes sense: if the operator has finished sending data with some timestamp, it can release the capability (but perhaps retain some new capability).</p>
<p>The other two arguments involve the production and consumption of messages. Recall that we are doing all this because operator might send data to each other. These arguments are how each operator indicates that it did actually produce some data, and correspondingly, that it received (and accepts responsibility for) some data.</p>
<p>There is an important contract here: an operator must not express a new capability without consuming data bearing that timestamp (or one before it), and an operator must not send data for a capability it has not expressed. The system can check these invariants for the operator, as it tracks the capabilities the operator current holds.</p>
<p>The boolean return value indicates whether the operator has any reason not expressed in its output why the computation should not be declared done. For example, operators may need to write data to the screen, persist data to disk, or do some clean-up. The system can ignore this result for the purposes of progress detection, but as the system is probably managing the operator as well as monitoring its progress, this indicates that it is not yet time to shut things down.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#nesting" id="user-content-nesting"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Nesting</h1>
<p>A great deal of the power of timely dataflow comes from the ability of each operator to be implemented by another "timely dataflow system", in the language above. While this is probably not actually a fresh system, the interface of the <code>Operate</code> trait gives us the flexibility to implement the operator internals with similar progress tracking logic at used to manage the operator itself.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#improvements" id="user-content-improvements"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Improvements</h1>
<p>An operator only produces connectivity summaries for paths along channels internal to the operator. This makes sense, because at this point it does not know about the connectivity from its outputs to inputs, and cannot reason about path along channels external to the operator.</p>
<p>It may be beneficial to consider a similar restriction of information for the summaries provided by the system to the operator: the output to input path summaries could be only along channels <em>external</em> to the operator. This communicates no less information, and the full path summaries can be reached by blending internal and external summaries, and it may communicate more information. Whether this information is valuable remains to be seen.</p>
<p>Similarly, it may help to communicate only changes in capabilities <em>external</em> to the operator, and not include capabilities that exist only because the operator itself expresses them, and has a path from its output back to its input. The operator can already see that capability, as it knows its own capabilities and the connectivity from its outputs to its inputs. This restriction on information would let an operator see that when it releases a capability internally, some expressed input capability is immediately released, without negotiating this information through its manager.</p>

        </div>

    </div>]