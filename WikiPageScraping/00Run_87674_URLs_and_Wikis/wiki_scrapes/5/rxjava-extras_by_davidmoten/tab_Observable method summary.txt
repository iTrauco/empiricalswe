[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <table>
<thead>
<tr>
<th>Method</th>
<th>Signature</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>Ob all(Func1)</td>
</tr>
<tr>
<td>amb</td>
<td>static Ob amb(Ob,Ob,Ob,Ob)</td>
</tr>
<tr>
<td>ambWith</td>
<td>Ob ambWith(Ob)</td>
</tr>
<tr>
<td>asObservable</td>
<td>Ob asOb()</td>
</tr>
<tr>
<td>buffer</td>
<td>Ob buffer(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>cache</td>
<td>Ob cache()</td>
</tr>
<tr>
<td>cast</td>
<td>Ob cast(Class)</td>
</tr>
<tr>
<td>collect</td>
<td>Ob collect(Func0,Action2)</td>
</tr>
<tr>
<td>combineLatest</td>
<td>static Ob combineLatest(Ob,Ob,Ob,Ob,Ob,Func5)</td>
</tr>
<tr>
<td>compose</td>
<td>Ob compose(Ob$Transformer)</td>
</tr>
<tr>
<td>concat</td>
<td>static Ob concat(Ob,Ob,Ob,Ob,Ob,Ob,Ob,Ob,Ob)</td>
</tr>
<tr>
<td>concatMap</td>
<td>Ob concatMap(Func1)</td>
</tr>
<tr>
<td>concatWith</td>
<td>Ob concatWith(Ob)</td>
</tr>
<tr>
<td>contains</td>
<td>Ob contains(Object)</td>
</tr>
<tr>
<td>count</td>
<td>Ob count()</td>
</tr>
<tr>
<td>countLong</td>
<td>Ob countLong()</td>
</tr>
<tr>
<td>create</td>
<td>static Ob create(Ob$OnSubscribe)</td>
</tr>
<tr>
<td>debounce</td>
<td>Ob debounce(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>defaultIfEmpty</td>
<td>Ob defaultIfEmpty(Object)</td>
</tr>
<tr>
<td>defer</td>
<td>static Ob defer(Func0)</td>
</tr>
<tr>
<td>delay</td>
<td>Ob delay(Func0,Func1)</td>
</tr>
<tr>
<td>delaySubscription</td>
<td>Ob delaySubscription(long,TimeUnit)</td>
</tr>
<tr>
<td>dematerialize</td>
<td>Ob dematerialize()</td>
</tr>
<tr>
<td>distinct</td>
<td>Ob distinct()</td>
</tr>
<tr>
<td>distinctUntilChanged</td>
<td>Ob distinctUntilChanged()</td>
</tr>
<tr>
<td>doOnCompleted</td>
<td>Ob doOnCompleted(Action0)</td>
</tr>
<tr>
<td>doOnEach</td>
<td>Ob doOnEach(Action1)</td>
</tr>
<tr>
<td>doOnError</td>
<td>Ob doOnError(Action1)</td>
</tr>
<tr>
<td>doOnNext</td>
<td>Ob doOnNext(Action1)</td>
</tr>
<tr>
<td>doOnRequest</td>
<td>Ob doOnRequest(Action1)</td>
</tr>
<tr>
<td>doOnSubscribe</td>
<td>Ob doOnSubscribe(Action0)</td>
</tr>
<tr>
<td>doOnTerminate</td>
<td>Ob doOnTerminate(Action0)</td>
</tr>
<tr>
<td>doOnUnsubscribe</td>
<td>Ob doOnUnsubscribe(Action0)</td>
</tr>
<tr>
<td>elementAt</td>
<td>Ob elementAt(int)</td>
</tr>
<tr>
<td>elementAtOrDefault</td>
<td>Ob elementAtOrDefault(int,Object)</td>
</tr>
<tr>
<td>empty</td>
<td>static Ob empty()</td>
</tr>
<tr>
<td>equals</td>
<td>boolean equals(Object)</td>
</tr>
<tr>
<td>error</td>
<td>static Ob error(Throwable)</td>
</tr>
<tr>
<td>exists</td>
<td>Ob exists(Func1)</td>
</tr>
<tr>
<td>filter</td>
<td>Ob filter(Func1)</td>
</tr>
<tr>
<td>finallyDo</td>
<td>Ob finallyDo(Action0)</td>
</tr>
<tr>
<td>first</td>
<td>Ob first(Func1)</td>
</tr>
<tr>
<td>firstOrDefault</td>
<td>Ob firstOrDefault(Object)</td>
</tr>
<tr>
<td>flatMap</td>
<td>Ob flatMap(Func1)</td>
</tr>
<tr>
<td>flatMapIterable</td>
<td>Ob flatMapIterable(Func1)</td>
</tr>
<tr>
<td>forEach</td>
<td>void forEach(Action1)</td>
</tr>
<tr>
<td>from</td>
<td>static Ob from(Iterable)</td>
</tr>
<tr>
<td>groupBy</td>
<td>Ob groupBy(Func1,Func1)</td>
</tr>
<tr>
<td>groupJoin</td>
<td>Ob groupJoin(Ob,Func1,Func1,Func2)</td>
</tr>
<tr>
<td>ignoreElements</td>
<td>Ob ignoreElements()</td>
</tr>
<tr>
<td>interval</td>
<td>static Ob interval(long,TimeUnit)</td>
</tr>
<tr>
<td>isEmpty</td>
<td>Ob isEmpty()</td>
</tr>
<tr>
<td>join</td>
<td>Ob join(Ob,Func1,Func1,Func2)</td>
</tr>
<tr>
<td>just</td>
<td>static Ob just(Object)</td>
</tr>
<tr>
<td>last</td>
<td>Ob last(Func1)</td>
</tr>
<tr>
<td>lastOrDefault</td>
<td>Ob lastOrDefault(Object)</td>
</tr>
<tr>
<td>lift</td>
<td>Ob lift(Ob$Operator)</td>
</tr>
<tr>
<td>limit</td>
<td>Ob limit(int)</td>
</tr>
<tr>
<td>map</td>
<td>Ob map(Func1)</td>
</tr>
<tr>
<td>materialize</td>
<td>Ob materialize()</td>
</tr>
<tr>
<td>merge</td>
<td>static Ob merge(Ob,Ob,Ob,Ob)</td>
</tr>
<tr>
<td>mergeDelayError</td>
<td>static Ob mergeDelayError(Ob,Ob,Ob,Ob,Ob,Ob)</td>
</tr>
<tr>
<td>mergeWith</td>
<td>Ob mergeWith(Ob)</td>
</tr>
<tr>
<td>nest</td>
<td>Ob nest()</td>
</tr>
<tr>
<td>never</td>
<td>static Ob never()</td>
</tr>
<tr>
<td>observeOn</td>
<td>Ob observeOn(Scheduler)</td>
</tr>
<tr>
<td>ofType</td>
<td>Ob ofType(Class)</td>
</tr>
<tr>
<td>onBackpressureBlock</td>
<td>Ob onBackpressureBlock(int)</td>
</tr>
<tr>
<td>onBackpressureBuffer</td>
<td>Ob onBackpressureBuffer(long,Action0)</td>
</tr>
<tr>
<td>onBackpressureDrop</td>
<td>Ob onBackpressureDrop(Action1)</td>
</tr>
<tr>
<td>onBackpressureLatest</td>
<td>Ob onBackpressureLatest()</td>
</tr>
<tr>
<td>onErrorResumeNext</td>
<td>Ob onErrorResumeNext(Ob)</td>
</tr>
<tr>
<td>onErrorReturn</td>
<td>Ob onErrorReturn(Func1)</td>
</tr>
<tr>
<td>onExceptionResumeNext</td>
<td>Ob onExceptionResumeNext(Ob)</td>
</tr>
<tr>
<td>publish</td>
<td>ConnectableOb publish()</td>
</tr>
<tr>
<td>range</td>
<td>static Ob range(int,int,Scheduler)</td>
</tr>
<tr>
<td>reduce</td>
<td>Ob reduce(Object,Func2)</td>
</tr>
<tr>
<td>repeat</td>
<td>Ob repeat()</td>
</tr>
<tr>
<td>repeatWhen</td>
<td>Ob repeatWhen(Func1,Scheduler)</td>
</tr>
<tr>
<td>replay</td>
<td>Ob replay(Func1,int,long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>retry</td>
<td>Ob retry(long)</td>
</tr>
<tr>
<td>retryWhen</td>
<td>Ob retryWhen(Func1)</td>
</tr>
<tr>
<td>sample</td>
<td>Ob sample(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>scan</td>
<td>Ob scan(Object,Func2)</td>
</tr>
<tr>
<td>sequenceEqual</td>
<td>static Ob sequenceEqual(Ob,Ob)</td>
</tr>
<tr>
<td>serialize</td>
<td>Ob serialize()</td>
</tr>
<tr>
<td>share</td>
<td>Ob share()</td>
</tr>
<tr>
<td>single</td>
<td>Ob single(Func1)</td>
</tr>
<tr>
<td>singleOrDefault</td>
<td>Ob singleOrDefault(Object,Func1)</td>
</tr>
<tr>
<td>skip</td>
<td>Ob skip(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>skipLast</td>
<td>Ob skipLast(int)</td>
</tr>
<tr>
<td>skipUntil</td>
<td>Ob skipUntil(Ob)</td>
</tr>
<tr>
<td>skipWhile</td>
<td>Ob skipWhile(Func1)</td>
</tr>
<tr>
<td>startWith</td>
<td>Ob startWith(Object,Object,Object,Object)</td>
</tr>
<tr>
<td>subscribe</td>
<td>Subscription subscribe()</td>
</tr>
<tr>
<td>subscribeOn</td>
<td>Ob subscribeOn(Scheduler)</td>
</tr>
<tr>
<td>switchIfEmpty</td>
<td>Ob switchIfEmpty(Ob)</td>
</tr>
<tr>
<td>switchMap</td>
<td>Ob switchMap(Func1)</td>
</tr>
<tr>
<td>switchOnNext</td>
<td>static Ob switchOnNext(Ob)</td>
</tr>
<tr>
<td>take</td>
<td>Ob take(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>takeFirst</td>
<td>Ob takeFirst(Func1)</td>
</tr>
<tr>
<td>takeLast</td>
<td>Ob takeLast(int,long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>takeLastBuffer</td>
<td>Ob takeLastBuffer(int)</td>
</tr>
<tr>
<td>takeUntil</td>
<td>Ob takeUntil(Func1)</td>
</tr>
<tr>
<td>takeWhile</td>
<td>Ob takeWhile(Func1)</td>
</tr>
<tr>
<td>throttleFirst</td>
<td>Ob throttleFirst(long,TimeUnit)</td>
</tr>
<tr>
<td>throttleLast</td>
<td>Ob throttleLast(long,TimeUnit)</td>
</tr>
<tr>
<td>throttleWithTimeout</td>
<td>Ob throttleWithTimeout(long,TimeUnit)</td>
</tr>
<tr>
<td>timeInterval</td>
<td>Ob timeInterval()</td>
</tr>
<tr>
<td>timeout</td>
<td>Ob timeout(long,TimeUnit,Scheduler)</td>
</tr>
<tr>
<td>timer</td>
<td>static Ob timer(long,long,TimeUnit)</td>
</tr>
<tr>
<td>timestamp</td>
<td>Ob timestamp(Scheduler)</td>
</tr>
<tr>
<td>toBlocking</td>
<td>BlockingOb toBlocking()</td>
</tr>
<tr>
<td>toList</td>
<td>Ob toList()</td>
</tr>
<tr>
<td>toMap</td>
<td>Ob toMap(Func1,Func1)</td>
</tr>
<tr>
<td>toMultimap</td>
<td>Ob toMultimap(Func1)</td>
</tr>
<tr>
<td>toSortedList</td>
<td>Ob toSortedList(Func2)</td>
</tr>
<tr>
<td>toString</td>
<td>String toString()</td>
</tr>
<tr>
<td>unsafeSubscribe</td>
<td>Subscription unsafeSubscribe(Subscriber)</td>
</tr>
<tr>
<td>unsubscribeOn</td>
<td>Ob unsubscribeOn(Scheduler)</td>
</tr>
<tr>
<td>using</td>
<td>static Ob using(Func0,Func1,Action1,boolean)</td>
</tr>
<tr>
<td>wait</td>
<td>void wait() throws InterruptedException</td>
</tr>
<tr>
<td>window</td>
<td>Ob window(long,long,TimeUnit)</td>
</tr>
<tr>
<td>withLatestFrom</td>
<td>Ob withLatestFrom(Ob,Func2)</td>
</tr>
<tr>
<td>zip</td>
<td>static Ob zip(Ob,Ob,Ob,Ob,Ob,Func5)</td>
</tr>
<tr>
<td>zipWith</td>
<td>Ob zipWith(Iterable,Func2)</td>
</tr>
</tbody>
</table>

        </div>

    </div>]