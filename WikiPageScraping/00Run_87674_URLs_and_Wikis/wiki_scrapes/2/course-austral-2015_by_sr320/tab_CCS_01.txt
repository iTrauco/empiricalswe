[<div class="wiki-body gollum-markdown-content instapaper_body" id="wiki-body">
        <div class="markdown-body">
          <p>#Core Computational Skills - Setup &amp; Unix</p>
<p><strong>Objective:</strong> Set-up computing environments for bioinformatics analysis and learn basic unix commands. Many of the latter educational material has been adapted from Software Carpentry.</p>
<hr/>
<p>###Cloud based services</p>
<ul>
<li>
<a href="https://github.com">GitHub</a>; Clients <a href="https://mac.github.com">Mac</a> - <a href="https://windows.github.com">Windows</a>
</li>
<li><a href="http://www.iplantcollaborative.org" rel="nofollow">iPlant Collaborative</a></li>
<li>
<a href="https://sqlshare.escience.washington.edu" rel="nofollow">SQLShare</a> <em>Google Account needed</em>
</li>
<li>
<a href="https://cloud.sagemath.com" rel="nofollow">SageMath Cloud</a> <em>can wait for invite</em>
</li>
<li><a href="https://usegalaxy.org" rel="nofollow">Galaxy</a></li>
</ul>
<p>###Local Software</p>
<ul>
<li>Git (MacOSX) For OS X 10.8 and higher, install Git for Mac by downloading and running the <a href="http://git-scm.com/downloads" rel="nofollow">installer</a>.</li>
<li>
<a href="https://msysgit.github.io/" rel="nofollow">Git Bash for Windows</a> This will provide you with both Git and Bash in the Git Bash program.</li>
<li><a href="http://ipython.org" rel="nofollow">IPython</a></li>
<li><a href="http://www.broadinstitute.org/software/igv/download" rel="nofollow">IGV</a></li>
</ul>
<hr/>
<p>#Setup and Tasks:</p>
<p>GitHub</p>
<ul>
<li>Create Repository</li>
<li>Answer Issue #</li>
</ul>
<p>iPlant Collaborative</p>
<ul>
<li>Open Discovery Environment</li>
<li>Copy Files</li>
<li>Start Job</li>
</ul>
<p>SQLShare</p>
<ul>
<li>Run Query to get all Proteins where name contains the word <code>immune</code> in the file <code>UniprotProtNamesReviewed_yes20130610</code>
</li>
</ul>
<p>SageMath Cloud</p>
<ul>
<li>Create Account</li>
<li>Start project for this course</li>
<li>Open new terminal</li>
<li>Open an IPython document</li>
</ul>
<p>Galaxy</p>
<ul>
<li>Create Account</li>
</ul>
<hr/>
<p>#Basics</p>
<p><strong>The Bash Shell</strong> - Bash is a commonly-used shell. Using a shell gives you more power to do more tasks more quickly with your computer.</p>
<p><strong>Git</strong> - Git is a state-of-the-art version control system. It lets you track who made changes to what when and has options for easily updating a shared or public version of your code on github.com.</p>
<p><strong>SQL</strong> - SQL is a specialized programming language used with databases.</p>
<hr/>
<p>#The Unix Shell</p>
<p><em>credit</em>:<br/>
<a href="http://software-carpentry.org/" rel="nofollow"><img alt="sc" data-canonical-src="http://eagle.fish.washington.edu/cnidarian/skitch/Files_and_Directories_1A575F8C.png" src="https://camo.githubusercontent.com/8077fae097017a8cbe1211c6bb8dd3e52c31a438/687474703a2f2f6561676c652e666973682e77617368696e67746f6e2e6564752f636e6964617269616e2f736b697463682f46696c65735f616e645f4469726563746f726965735f31413537354638432e706e67"/></a><br/>
Copyright (c) Software Carpentry<br/>
see also<br/>
<a href="http://sophieclayton.github.io/2015-01-15-uw/novice/shell/" rel="nofollow">http://sophieclayton.github.io/2015-01-15-uw/novice/shell/</a></p>
<hr/>
<p>#Intro</p>
<blockquote>
<h2>
<a aria-hidden="true" class="anchor" href="#learning-objectives" id="user-content-learning-objectives"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Learning Objectives</h2>
<ul>
<li>Explain the similarities and differences between a file and a directory.</li>
<li>Translate an absolute path into a relative path and vice versa.</li>
<li>Construct absolute and relative paths that identify specific files and directories.</li>
<li>Identify the actual command, flags, and filenames in a command-line call.</li>
<li>Demonstrate the use of tab completion, and explain its advantages.</li>
</ul>
</blockquote>
<hr/>
<p><a href="https://www.dropbox.com/s/lqldl2zghaa3en4/filesystem.zip?dl=0" rel="nofollow">Files for this exercise</a></p>
<p>The part of the operating system responsible for managing files and directories
is called the <strong>file system</strong>.
It organizes our data into files,
which hold information,
and directories (also called "folders"),
which hold files or other directories.</p>
<p>Several commands are frequently used to create, inspect, rename, and delete files and directories.
To start exploring them,
let's open a shell window:</p>
<pre><code>$
</code></pre>
<p>The dollar sign is a <strong>prompt</strong>,
which shows us that the shell is waiting for input;
your shell may show something more elaborate.</p>
<p>Type the command <code>whoami</code>,
then press the Enter key (sometimes marked Return) to send the command to the shell.
The command's output is the ID of the current user,
i.e.,
it shows us who the shell thinks we are:</p>
<pre><code>$ whoami
</code></pre>
<pre><code>nelle
</code></pre>
<p>More specifically, when we type <code>whoami</code> the shell:</p>
<ol>
<li>finds a program called <code>whoami</code>,</li>
<li>runs that program,</li>
<li>displays that program's output, then</li>
<li>displays a new prompt to tell us that it's ready for more commands.</li>
</ol>
<p>Next,
let's find out where we are by running a command called <code>pwd</code>
(which stands for "print working directory").
At any moment,
our <strong>current working directory</strong>
is our current default directory,
i.e.,
the directory that the computer assumes we want to run commands in
unless we explicitly specify something else.
Here,
the computer's response is <code>/users/nelle</code>,
which is Nelle's <strong>home directory</strong>:</p>
<pre><code>$ pwd
</code></pre>
<pre><code>/users/nelle
</code></pre>

<hr/>
<p>To understand what a "home directory" is,
let's have a look at how the file system as a whole is organized.
At the top is the <strong>root directory</strong>
that holds everything else.
We refer to it using a slash character <code>/</code> on its own;
this is the leading slash in <code>/users/nelle</code>.</p>
<p>Inside that directory are several other directories:
<code>bin</code> (which is where some built-in programs are stored),
<code>data</code> (for miscellaneous data files),
<code>users</code> (where users' personal directories are located),
<code>tmp</code> (for temporary files that don't need to be stored long-term),
and so on:</p>
<img alt="The Filesystem" data-canonical-src="http://eagle.fish.washington.edu/cnidarian/skitch/Files_and_Directories_1A575CA9.png" src="https://camo.githubusercontent.com/e86634d9d0cd9d0de647d3ab53b9116075a2ed2e/687474703a2f2f6561676c652e666973682e77617368696e67746f6e2e6564752f636e6964617269616e2f736b697463682f46696c65735f616e645f4469726563746f726965735f31413537354341392e706e67"/>
<p>We know that our current working directory <code>/users/nelle</code> is stored inside <code>/users</code>
because <code>/users</code> is the first part of its name.
Similarly,
we know that <code>/users</code> is stored inside the root directory <code>/</code>
because its name begins with <code>/</code>.</p>
<p>Underneath <code>/users</code>,
we find one directory for each user with an account on this machine.
The Mummy's files are stored in <code>/users/gorgon</code>,
Wolfman's in <code>/users/dru</code>,
and ours in <code>/users/nelle</code>,
which is why <code>nelle</code> is the last part of the directory's name.</p>
<img alt="Home Directories" data-canonical-src="http://eagle.fish.washington.edu/cnidarian/skitch/Files_and_Directories_1A575CC7.png" src="https://camo.githubusercontent.com/ea9ad5b1c9a04de70ad43940ae5f8affbcca401b/687474703a2f2f6561676c652e666973682e77617368696e67746f6e2e6564752f636e6964617269616e2f736b697463682f46696c65735f616e645f4469726563746f726965735f31413537354343372e706e67"/>
<blockquote>
<p>Notice that there are two meanings for the <code>/</code> character.
When it appears at the front of a file or directory name,
it refers to the root directory. When it appears <em>inside</em> a name,
it's just a separator.</p>
</blockquote>
<p>##ls</p>
<p>Let's see what's in Nelle's home directory by running <code>ls</code>,
which stands for "listing":</p>
<pre><code>$ ls
</code></pre>
<pre><code>creatures  molecules           pizza.cfg
data       north-pacific-gyre  solar.pdf
Desktop    notes.txt           writing
</code></pre>
<img alt="Nelle's Home Directory" data-canonical-src="http://eagle.fish.washington.edu/cnidarian/skitch/Files_and_Directories_1A575D2F.png" src="https://camo.githubusercontent.com/191fb0f3a7a213f70d57af2f3d11a0570af7b39e/687474703a2f2f6561676c652e666973682e77617368696e67746f6e2e6564752f636e6964617269616e2f736b697463682f46696c65735f616e645f4469726563746f726965735f31413537354432462e706e67"/>
<p><code>ls</code> prints the names of the files and directories in the current directory in alphabetical order,
arranged neatly into columns.
We can make its output more comprehensible by using the <strong>flag</strong> <code>-F</code>,
which tells <code>ls</code> to add a trailing <code>/</code> to the names of directories:</p>
<pre><code>$ ls -F
</code></pre>
<pre><code>creatures/  molecules/           pizza.cfg
data/       north-pacific-gyre/  solar.pdf
Desktop/    notes.txt            writing/
</code></pre>
<p>Here,
we can see that <code>/users/nelle</code> contains seven <strong>sub-directories</strong>.
The names that don't have trailing slashes,
like <code>notes.txt</code>, <code>pizza.cfg</code>, and <code>solar.pdf</code>,
are plain old files.
And note that there is a space between <code>ls</code> and <code>-F</code>:
without it,
the shell thinks we're trying to run a command called <code>ls-F</code>,
which doesn't exist.</p>

<p>##relative path
Now let's take a look at what's in Nelle's <code>data</code> directory by running <code>ls -F data</code>,
i.e.,
the command <code>ls</code> with the <strong>arguments</strong> <code>-F</code> and <code>data</code>.
The second argument --- the one <em>without</em> a leading dash --- tells <code>ls</code> that
we want a listing of something other than our current working directory:</p>
<pre><code>$ ls -F data
</code></pre>
<pre><code>amino-acids.txt   elements/     morse.txt
pdb/              planets.txt   sunspot.txt
</code></pre>
<p>The output shows us that there are four text files and two sub-sub-directories.
Organizing things hierarchically in this way helps us keep track of our work:
it's possible to put hundreds of files in our home directory,
just as it's possible to pile hundreds of printed papers on our desk,
but it's a self-defeating strategy.</p>
<p>Notice, by the way that we spelled the directory name <code>data</code>.
It doesn't have a trailing slash:
that's added to directory names by <code>ls</code> when we use the <code>-F</code> flag to help us tell things apart.
And it doesn't begin with a slash because it's a <strong>relative path</strong>,
i.e., it tells <code>ls</code> how to find something from where we are,
rather than from the root of the file system.</p>

<p>##absolute path
If we run <code>ls -F /data</code> (<em>with</em> a leading slash) we get a different answer,
because <code>/data</code> is an <strong>absolute path</strong>:</p>
<pre><code>$ ls -F /data
</code></pre>
<pre><code>access.log    backup/    hardware.cfg
network.cfg
</code></pre>
<p>The leading <code>/</code> tells the computer to follow the path from the root of the filesystem,
so it always refers to exactly one directory,
no matter where we are when we run the command.</p>
<p>What if we want to change our current working directory?
Before we do this,
<code>pwd</code> shows us that we're in <code>/users/nelle</code>,
and <code>ls</code> without any arguments shows us that directory's contents:</p>
<pre><code>$ pwd
</code></pre>
<pre><code>/users/nelle
</code></pre>
<pre><code>$ ls
</code></pre>
<pre><code>creatures  molecules           pizza.cfg
data       north-pacific-gyre  solar.pdf
Desktop    notes.txt           writing
</code></pre>
<p>We can use <code>cd</code> followed by a directory name to change our working directory.
<code>cd</code> stands for "change directory",
which is a bit misleading:
the command doesn't change the directory,
it changes the shell's idea of what directory we are in.</p>
<pre><code>$ cd data
</code></pre>
<p><code>cd</code> doesn't print anything,
but if we run <code>pwd</code> after it, we can see that we are now in <code>/users/nelle/data</code>.
If we run <code>ls</code> without arguments now,
it lists the contents of <code>/users/nelle/data</code>,
because that's where we now are:</p>
<pre><code>$ pwd
</code></pre>
<pre><code>/users/nelle/data
</code></pre>
<pre><code>$ ls -F
</code></pre>
<pre><code>amino-acids.txt   elements/     morse.txt
pdb/              planets.txt   sunspot.txt
</code></pre>
<p>We now know how to go down the directory tree:
how do we go up?
We could use an absolute path:</p>
<pre><code>$ cd /users/nelle
</code></pre>
<p>but it's almost always simpler to use <code>cd ..</code> to go up one level:</p>
<pre><code>$ pwd
</code></pre>
<pre><code>/users/nelle/data
</code></pre>
<pre><code>$ cd ..
</code></pre>
<p><code>..</code> is a special directory name meaning
"the directory containing this one",
or more succinctly,
the <strong>parent</strong> of the current directory.
Sure enough,
if we run <code>pwd</code> after running <code>cd ..</code>, we're back in <code>/users/nelle</code>:</p>
<pre><code>$ pwd
</code></pre>
<pre><code>/users/nelle
</code></pre>
<p>The special directory <code>..</code> doesn't usually show up when we run <code>ls</code>.
If we want to display it, we can give <code>ls</code> the <code>-a</code> flag:</p>
<pre><code>$ ls -F -a
</code></pre>
<pre><code>./          Desktop/             pizza.cfg
../         molecules/           solar.pdf
creatures/  north-pacific-gyre/  writing/
data/       notes.txt
</code></pre>
<p><code>-a</code> stands for "show all";
it forces <code>ls</code> to show us file and directory names that begin with <code>.</code>,
such as <code>..</code> (which, if we're in <code>/users/nelle</code>, refers to the <code>/users</code> directory).
As you can see,
it also displays another special directory that's just called <code>.</code>,
which means "the current working directory".
It may seem redundant to have a name for it,
but we'll see some uses for it soon.</p>

<p>##Nelle's Pipeline: Organizing Files</p>
<p>Knowing just this much about files and directories,
Nelle is ready to organize the files that the protein assay machine will create.
First,
she creates a directory called <code>north-pacific-gyre</code>
(to remind herself where the data came from).
Inside that,
she creates a directory called <code>2012-07-03</code>,
which is the date she started processing the samples.
She used to use names like <code>conference-paper</code> and <code>revised-results</code>,
but she found them hard to understand after a couple of years.
(The final straw was when she found herself creating
a directory called <code>revised-revised-results-3</code>.)</p>
<blockquote>
<p>Nelle names her directories "year-month-day",
with leading zeroes for months and days,
because the shell displays file and directory names in alphabetical order.
If she used month names,
December would come before July;
if she didn't use leading zeroes,
November ('11') would come before July ('7').</p>
</blockquote>
<p>Each of her physical samples is labelled according to her lab's convention
with a unique ten-character ID,
such as "NENE01729A".
This is what she used in her collection log
to record the location, time, depth, and other characteristics of the sample,
so she decides to use it as part of each data file's name.
Since the assay machine's output is plain text,
she will call her files <code>NENE01729A.txt</code>, <code>NENE01812A.txt</code>, and so on.
All 1520 files will go into the same directory.</p>
<p>If she is in her home directory,
Nelle can see what files she has using the command:</p>
<pre><code>$ ls north-pacific-gyre/2012-07-03/
</code></pre>
<p>This is a lot to type,
but she can let the shell do most of the work.
If she types:</p>
<pre><code>$ ls nor
</code></pre>
<p>and then presses tab,
the shell automatically completes the directory name for her:</p>
<pre><code>$ ls north-pacific-gyre/
</code></pre>
<p>If she presses tab again,
Bash will add <code>2012-07-03/</code> to the command,
since it's the only possible completion.
Pressing tab again does nothing,
since there are 1520 possibilities;
pressing tab twice brings up a list of all the files,
and so on.
This is called <strong>tab completion</strong>,
and we will see it in many other tools as we go on.</p>
<p>##Key Points</p>
<ul>
<li>The file system is responsible for managing information on the disk.</li>
<li>Information is stored in files, which are stored in directories (folders).</li>
<li>Directories can also store other directories, which forms a directory tree.</li>
<li>
<code>/</code> on its own is the root directory of the whole filesystem.</li>
<li>A relative path specifies a location starting from the current location.</li>
<li>An absolute path specifies a location from the root of the filesystem.</li>
<li>Directory names in a path are separated with '/' on Unix, but '' on Windows.</li>
<li>'..' means "the directory above the current one"; '.' on its own means "the current directory".</li>
<li>Most files' names are <code>something.extension</code>. The extension isn't required, and doesn't guarantee anything, but is normally used to indicate the type of data in the file.</li>
<li>Most commands take options (flags) which begin with a '-'.</li>
</ul>

<hr/>
<h1>
<a aria-hidden="true" class="anchor" href="#creating-things" id="user-content-creating-things"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Creating Things</h1>
<h4>
<a aria-hidden="true" class="anchor" href="#objectives" id="user-content-objectives"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Objectives</h4>
<ul>
<li>Create a directory hierarchy that matches a given diagram.</li>
<li>Create files in that hierarchy using an editor or by copying and renaming existing files.</li>
<li>Display the contents of a directory using the command line.</li>
<li>Delete specified files and/or directories.</li>
</ul>
<p>We now know how to explore files and directories, but how do we create them in the first place? Let's go back to Nelle's home directory, <code>/users/nelle</code>, and use <code>ls -F</code> to see what it contains:</p>
<pre><code>$ pwd

/users/nelle

$ ls -F

creatures/  molecules/           pizza.cfg
data/       north-pacific-gyre/  solar.pdf
Desktop/    notes.txt            writing/
</code></pre>
<p>Let's create a new directory called <code>thesis</code> using the command <code>mkdir thesis</code> (which has no output):</p>
<pre><code>$ mkdir thesis
</code></pre>
<p>As you might (or might not) guess from its name, <code>mkdir</code> means "make directory". Since <code>thesis</code> is a relative path (i.e., doesn't have a leading slash), the new directory is made below the current working directory:</p>
<pre><code>$ ls -F

creatures/  north-pacific-gyre/  thesis/
data/       notes.txt            writing/
Desktop/    pizza.cfg
molecules/  solar.pdf
</code></pre>
<p>However, there's nothing in it yet:</p>
<pre><code>$ ls -F thesis
</code></pre>
<p>Let's change our working directory to <code>thesis</code> using <code>cd</code>, then run a text editor called Nano to create a file called <code>draft.txt</code>:</p>
<pre><code>$ cd thesis
$ nano draft.txt
</code></pre>
<h4>
<a aria-hidden="true" class="anchor" href="#which-editor" id="user-content-which-editor"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Which Editor?</h4>
<p>When we say, "<code>nano</code> is a text editor," we really do mean "text": it can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because almost anyone can drive it anywhere without training, but please use something more powerful for real work. On Unix systems (such as Linux and Mac OS X), many programmers use <a href="http://www.gnu.org/software/emacs/" rel="nofollow">Emacs</a> or <a href="http://www.vim.org/" rel="nofollow">Vim</a> (both of which are completely unintuitive, even by Unix standards), or a graphical editor such as <a href="http://projects.gnome.org/gedit/" rel="nofollow">Gedit</a>. On Windows, you may wish to use <a href="http://notepad-plus-plus.org/" rel="nofollow">Notepad++</a>. On a Mac, <a href="http://www.barebones.com/products/textwrangler/" rel="nofollow">TextWrangler</a> is an option.</p>
<p>No matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer's start menu, it may want to save files in your desktop or documents directory instead. You can change this by navigating to another directory the first time you "Save As…"</p>
<p>Let's type in a few lines of text, then use Control-O to write our data to disk:</p>
<p><img alt="Nano in Action" data-canonical-src="http://eagle.fish.washington.edu/cnidarian/skitch/Creating_Things_1A576087.png" src="https://camo.githubusercontent.com/782a6c45fae7fa600e566f148c446fd90dc131e2/687474703a2f2f6561676c652e666973682e77617368696e67746f6e2e6564752f636e6964617269616e2f736b697463682f4372656174696e675f5468696e67735f31413537363038372e706e67"/></p>
<p>Once our file is saved, we can use Control-X to quit the editor and return to the shell. (Unix documentation often uses the shorthand <code>^A</code> to mean "control-A".) <code>nano</code> doesn't leave any output on the screen after it exits, but <code>ls</code> now shows that we have created a file called <code>draft.txt</code>:</p>
<pre><code>$ ls

draft.txt
</code></pre>
<p>Let's tidy up by running <code>rm draft.txt</code>:</p>
<pre><code>$ rm draft.txt
</code></pre>
<p>This command removes files ("rm" is short for "remove"). If we run <code>ls</code> again, its output is empty once more, which tells us that our file is gone:</p>
<pre><code>$ ls
</code></pre>
<h4>
<a aria-hidden="true" class="anchor" href="#deleting-is-forever" id="user-content-deleting-is-forever"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Deleting Is Forever</h4>
<p>Unix doesn't have a trash bin: when we delete files, they are unhooked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there's no guarantee they'll work in any particular situation, since the computer may recycle the file's disk space right away.</p>

<hr/>
<h1>
<a aria-hidden="true" class="anchor" href="#pipes-and-filters" id="user-content-pipes-and-filters"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Pipes and Filters</h1>
<h4>
<a aria-hidden="true" class="anchor" href="#objectives-1" id="user-content-objectives-1"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Objectives</h4>
<ul>
<li>Redirect a command's output to a file.</li>
<li>Process a file instead of keyboard input using redirection.</li>
<li>Construct command pipelines with two or more stages.</li>
<li>Explain what usually happens if a program or pipeline isn't given any input to process.</li>
<li>Explain Unix's "small pieces, loosely joined" philosophy.</li>
</ul>
<p>Now that we know a few basic commands, we can finally look at the shell's most powerful feature: the ease with which it lets us combine existing programs in new ways. We'll start with a directory called <code>molecules</code> that contains six files describing some simple organic molecules. The <code>.pdb</code> extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.</p>
<pre><code>$ ls molecules

cubane.pdb    ethane.pdb    methane.pdb
octane.pdb    pentane.pdb   propane.pdb
</code></pre>
<p>##word count</p>
<p>Let's go into that directory with <code>cd</code> and run the command <code>wc *.pdb</code>. <code>wc</code> is the "word count" command: it counts the number of lines, words, and characters in files. The <code>*</code> in <code>*.pdb</code> matches zero or more characters, so the shell turns <code>*.pdb</code> into a complete list of <code>.pdb</code> files:</p>
<pre><code>$ cd molecules
$ wc *.pdb

  20  156 1158 cubane.pdb
  12   84  622 ethane.pdb
   9   57  422 methane.pdb
  30  246 1828 octane.pdb
  21  165 1226 pentane.pdb
  15  111  825 propane.pdb
 107  819 6081 total
</code></pre>
<h3>
<a aria-hidden="true" class="anchor" href="#wildcards" id="user-content-wildcards"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Wildcards</h3>
<p><code>*</code> is a <a href="http://notepad-plus-plus.org/" rel="nofollow">wildcard</a>. It matches zero or more characters, so <code>*.pdb</code> matches <code>ethane.pdb</code>, <code>propane.pdb</code>, and so on. On the other hand, <code>p*.pdb</code> only matches <code>pentane.pdb</code> and <code>propane.pdb</code>, because the 'p' at the front only matches itself.
&gt;
&gt; <code>?</code> is also a wildcard, but it only matches a single character. This means that <code>p?.pdb</code> matches <code>pi.pdb</code> or <code>p5.pdb</code>, but not <code>propane.pdb</code>. We can use any number of wildcards at a time: for example, <code>p*.p?*</code> matches anything that starts with a 'p' and ends with '.', 'p', and at least one more character (since the '?' has to match one character, and the final '<em>' can match any number of characters). Thus, <code>p*.p?*</code> would match <code>preferred.practice</code>, and even <code>p.pi</code> (since the first '</em>' can match no characters at all), but not <code>quality.practice</code> (doesn't start with 'p') or <code>preferred.p</code> (there isn't at least one character after the '.p').
&gt;
&gt; When the shell sees a wildcard, it expands the wildcard to create a list of matching filenames <em>before</em> running the command that was asked for. This means that commands like <code>wc</code> and <code>ls</code> never see the wildcard characters, just what those wildcards matched. This is another example of orthogonal design.</p>
<p>If we run <code>wc -l</code> instead of just <code>wc</code>, the output shows only the number of lines per file:</p>
<pre><code>$ wc -l *.pdb

  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total
</code></pre>
<p>We can also use <code>-w</code> to get only the number of words, or <code>-c</code> to get only the number of characters.</p>
<p>##redirect
Which of these files is shortest? It's an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:</p>
<pre><code>$ wc -l *.pdb &gt; lengths
</code></pre>
<p>The <code>&gt;</code> tells the shell to <a href="http://sophieclayton.github.io/img/nano-screenshot.png" rel="nofollow">redirect</a> the command's output to a file instead of printing it to the screen. The shell will create the file if it doesn't exist, or overwrite the contents of that file if it does. (This is why there is no screen output: everything that <code>wc</code> would have printed has gone into the file <code>lengths</code> instead.) <code>ls lengths</code> confirms that the file exists:</p>
<pre><code>$ ls lengths

lengths
</code></pre>
<p>##cat
We can now send the content of <code>lengths</code> to the screen using <code>cat lengths</code>. <code>cat</code> stands for "concatenate": it prints the contents of files one after another. There's only one file in this case, so <code>cat</code> just shows us what it contains:</p>
<pre><code>$ cat lengths

  20  cubane.pdb
  12  ethane.pdb
   9  methane.pdb
  30  octane.pdb
  21  pentane.pdb
  15  propane.pdb
 107  total
</code></pre>
<p>##sort
Now let's use the <code>sort</code> command to sort its contents. We will also use the -n flag to specify that the sort is numerical instead of alphabetical. This does <em>not</em> change the file; instead, it sends the sorted result to the screen:</p>
<pre><code>$ sort -n lengths

  9  methane.pdb
 12  ethane.pdb
 15  propane.pdb
 20  cubane.pdb
 21  pentane.pdb
 30  octane.pdb
107  total
</code></pre>
<p>##head
We can put the sorted list of lines in another temporary file called <code>sorted-lengths</code> by putting <code>&gt; sorted-lengths</code> after the command, just as we used <code>&gt; lengths</code> to put the output of <code>wc</code> into <code>lengths</code>. Once we've done that, we can run another command called <code>head</code> to get the first few lines in <code>sorted-lengths</code>:</p>
<pre><code>$ sort -n lengths &gt; sorted-lengths
$ head -1 sorted-lengths

  9  methane.pdb
</code></pre>
<p>Using the parameter <code>-1</code> with <code>head</code> tells it that we only want the first line of the file; <code>-20</code> would get the first 20, and so on. Since <code>sorted-lengths</code> contains the lengths of our files ordered from least to greatest, the output of <code>head</code> must be the file with the fewest lines.
##pipe
If you think this is confusing, you're in good company: even once you understand what <code>wc</code>, <code>sort</code>, and <code>head</code> do, all those intermediate files make it hard to follow what's going on. We can make it easier to understand by running <code>sort</code> and <code>head</code> together:</p>
<pre><code>$ sort -n lengths | head -1

  9  methane.pdb
</code></pre>
<p>The vertical bar between the two commands is called a <a href="../../gloss.html#pipe">pipe</a>. It tells the shell that we want to use the output of the command on the left as the input to the command on the right. The computer might create a temporary file if it needs to, or copy data from one program to the other in memory, or something else entirely; we don't have to know or care.</p>
<p>We can use another pipe to send the output of <code>wc</code> directly to <code>sort</code>, which then sends its output to <code>head</code>:</p>
<pre><code>$ wc -l *.pdb | sort -n | head -1

  9  methane.pdb
</code></pre>
<blockquote>
</blockquote>
<p>Here's what actually happens behind the scenes when we create a pipe. When a computer runs a program—any program—it creates a <a href="../../gloss.html#process">process</a> in memory to hold the program's software and its current state. Every process has an input channel called <a href="../../gloss.html#standard-input">standard input</a>. (By this point, you may be surprised that the name is so memorable, but don't worry: most Unix programmers call it "stdin". Every process also has a default output channel called <a href="../../gloss.html#standard-output">standard output</a> (or "stdout").</p>
<blockquote>
</blockquote>
<p>The shell is actually just another program. Under normal circumstances, whatever we type on the keyboard is sent to the shell on its standard input, and whatever it produces on standard output is displayed on our screen. When we tell the shell to run a program, it creates a new process and temporarily sends whatever we type on our keyboard to that process's standard input, and whatever the process sends to standard output to the screen.</p>
<blockquote>
</blockquote>
<p>Here's what happens when we run <code>wc -l *.pdb &gt; lengths</code>. The shell starts by telling the computer to create a new process to run the <code>wc</code> program. Since we've provided some filenames as parameters, <code>wc</code> reads from them instead of from standard input. And since we've used <code>&gt;</code> to redirect output to a file, the shell connects the process's standard output to that file.</p>
<blockquote>
</blockquote>
<p>If we run <code>wc -l *.pdb | sort -n</code> instead, the shell creates two processes (one for each process in the pipe) so that <code>wc</code> and <code>sort</code> run simultaneously. The standard output of <code>wc</code> is fed directly to the standard input of <code>sort</code>; since there's no redirection with <code>&gt;</code>, <code>sort</code>'s output goes to the screen. And if we run <code>wc -l *.pdb | sort -n | head -1</code>, we get three processes with data flowing from the files, through <code>wc</code> to <code>sort</code>, and from <code>sort</code> through <code>head</code> to the screen.</p>
<blockquote>
</blockquote>
<p>This simple idea is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called <a href="../../gloss.html#pipe-and-filter">pipes and filters</a>. We've already seen pipes; a <a href="../../gloss.html#filter">filter</a> is a program like <code>wc</code> or <code>sort</code> that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way: unless told to do otherwise, they read from standard input, do something with what they've read, and write to standard output.</p>
<blockquote>
</blockquote>
<p>The key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can <em>and should</em> write your programs this way so that you and other people can put those programs into pipes to multiply their power.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#redirecting-input" id="user-content-redirecting-input"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Redirecting Input</h4>
<p>As well as using <code>&gt;</code> to redirect a program's output, we can use <code>&lt;</code> to redirect its input, i.e., to read from a file instead of from standard input. For example, instead of writing <code>wc ammonia.pdb</code>, we could write <code>wc &lt; ammonia.pdb</code>. In the first case, <code>wc</code> gets a command line parameter telling it what file to open. In the second, <code>wc</code> doesn't have any command line parameters, so it reads from standard input, but we have told the shell to send the contents of <code>ammonia.pdb</code> to <code>wc</code>'s standard input.</p>
<h1>
<a aria-hidden="true" class="anchor" href="#nelles-pipeline-checking-files" id="user-content-nelles-pipeline-checking-files"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Nelle's Pipeline: Checking Files</h1>
<p>Nelle has run her samples through the assay machines and created 1520 files in the <code>north-pacific-gyre/2012-07-03</code> directory described earlier. As a quick sanity check, she types:</p>
<pre><code>$ cd north-pacific-gyre/2012-07-03
$ wc -l *.txt
</code></pre>
<p>The output is 1520 lines that look like this:</p>
<pre><code>300 NENE01729A.txt
300 NENE01729B.txt
300 NENE01736A.txt
300 NENE01751A.txt
300 NENE01751B.txt
300 NENE01812A.txt
... ...
</code></pre>
<p>Now she types this:</p>
<pre><code>$ wc -l *.txt | sort -n | head -5

 240 NENE02018B.txt
 300 NENE01729A.txt
 300 NENE01729B.txt
 300 NENE01736A.txt
 300 NENE01751A.txt
</code></pre>
<p>Whoops: one of the files is 60 lines shorter than the others. When she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning—someone was probably in using the machine on the weekend, and she forgot to reset it. Before re-running that sample, she checks to see if any files have too much data:</p>
<pre><code>$ wc -l *.txt | sort -n | tail -5

 300 NENE02040A.txt
 300 NENE02040B.txt
 300 NENE02040Z.txt
 300 NENE02043A.txt
 300 NENE02043B.txt
</code></pre>
<p>Those numbers look good—but what's that 'Z' doing there in the third-to-last line? All of her samples should be marked 'A' or 'B'; by convention, her lab uses 'Z' to indicate samples with missing information. To find others like it, she does this:</p>
<pre><code>$ ls *Z.txt

NENE01971Z.txt    NENE02040Z.txt
</code></pre>
<p>Sure enough, when she checks the log on her laptop, there's no depth recorded for either of those samples. Since it's too late to get the information any other way, she must exclude those two files from her analysis. She could just delete them using <code>rm</code>, but there are actually some analyses she might do later where depth doesn't matter, so instead, she'll just be careful later on to select files using the wildcard expression <code>[*AB].txt</code>. As always, the '*' matches any number of characters; the expression [<code>AB]</code> matches either an 'A' or a 'B', so this matches all the valid data files she has.</p>
<hr/>
<h4>
<a aria-hidden="true" class="anchor" href="#key-points" id="user-content-key-points"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Key Points</h4>
<ul>
<li>
<code>command &gt; file</code> redirects a command's output to a file.</li>
<li>
<code>first | second</code> is a pipeline: the output of the first command is used as the input to the second.</li>
<li>The best way to use the shell is to use pipes to combine simple single-purpose programs (filters).</li>
</ul>


        </div>

    </div>]